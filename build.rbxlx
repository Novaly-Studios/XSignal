<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBXC1C03A181C324603A4A926AD0CFFB828">
		<Properties>
			<bool name="AllowThirdPartySales">false</bool>
			<token name="AnimationWeightedBlendFix">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="ClientAnimatorThrottling">0</token>
			<string name="CollisionGroups">Default^0^-1</string>
			<Ref name="CurrentCamera">RBX7C1B6E2EDB264188BA9A5BDE4E0FD89A</Ref>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<Vector3 name="GlobalWind">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<float name="Gravity">196.199997</float>
			<token name="HumanoidOnlySetCollisionsOnStateChange">0</token>
			<token name="InterpolationThrottling">0</token>
			<token name="LevelOfDetail">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">false</bool>
			<token name="PhysicsInertiaAndVolumeFix">0</token>
			<token name="PhysicsSteppingMethod">0</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="ReplicateInstanceDestroySetting">0</token>
			<token name="Retargeting">0</token>
			<token name="SignalBehavior">0</token>
			<int64 name="SourceAssetId">-1</int64>
			<token name="StreamOutBehavior">0</token>
			<bool name="StreamingEnabled">false</bool>
			<int name="StreamingMinRadius">64</int>
			<token name="StreamingPauseMode">0</token>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001e0ea</UniqueId>
			<OptionalCoordinateFrame name="WorldPivotData">
				<CFrame>
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CFrame>
			</OptionalCoordinateFrame>
		</Properties>
		<Item class="Camera" referent="RBX7C1B6E2EDB264188BA9A5BDE4E0FD89A">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>23.2884769</X>
					<Y>41.4810944</Y>
					<Z>-42.6027985</Z>
					<R00>0.0936376005</R00>
					<R01>0.0262817014</R01>
					<R02>0.995259404</R02>
					<R10>2.32830616e-10</R10>
					<R11>0.999651492</R11>
					<R12>-0.0263976827</R12>
					<R20>-0.995606363</R20>
					<R21>0.00247181579</R21>
					<R22>0.093604967</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>21.2979565</X>
					<Y>41.5338898</Y>
					<Z>-42.7900085</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb16</UniqueId>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBX7F79C1DA73AF4D0D88ECC4AE2FD5B809">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">false</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb89</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBXD6F3A8E9DB9748A1840625C46CD4624E">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">false</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fac9</UniqueId>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBX740559B97D354183A637DD8A4D2E2C87">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fad5</UniqueId>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBX533489DDDB984D479B5800763DD663DF">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fad6</UniqueId>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBXC2B16996E6B54AC6A5354522DAB4822E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fadb</UniqueId>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBX6D5FB714F59B4347854E06471AF19FCA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fadc</UniqueId>
		</Properties>
	</Item>
	<Item class="Players" referent="RBXC21848D5EE014B0D8AEA2A3449B09A94">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CharacterAutoLoads">true</bool>
			<int name="MaxPlayersInternal">12</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">0</int>
			<float name="RespawnTime">5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fade</UniqueId>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fae2</UniqueId>
		</Properties>
		<Item class="ModuleScript" referent="1">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">TypeGuard</string>
				<string name="ScriptGuid">{2D80AE25-CA55-4726-8A6F-2B265932E673}</string>
				<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["tpc9000_typeguard@2.2.0"]["typeguard"])
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb81</UniqueId>
			</Properties>
		</Item>
		<Item class="Folder" referent="2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">_Index</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb82</UniqueId>
			</Properties>
			<Item class="Folder" referent="3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">tpc9000_typeguard@2.2.0</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb83</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">typeguard</string>
						<string name="ScriptGuid">{D669367E-E4E8-4092-9424-BB30ADD0F577}</string>
						<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
-- @TODO This script really needs splitting up into sub-modules

local CHECK_TAG_SUFFIX = ".Check"
local EMPTY_STRING = ""

local TYPE_SOMETHING = "something"
local TYPE_ENUM_ITEM = "EnumItem"
local TYPE_INSTANCE = "Instance"
local TYPE_ENUM = "Enum"

local TYPE_FUNCTION = "function"
local TYPE_USERDATA = "userdata"
local TYPE_BOOLEAN = "boolean"
local TYPE_THREAD = "thread"
local TYPE_NUMBER = "number"
local TYPE_STRING = "string"
local TYPE_TABLE = "table"
local TYPE_NIL = "nil"

local INVALID_ARGUMENT = "Invalid argument #%s (%s expected, got %s)"
local INVALID_TYPE = "Expected %s, got %s"

-- Cache up here so these arrays aren't re-created with every function call for the simple checking system
local EXPECT_ENUM_OR_ENUM_ITEM_OR_FUNCTION = {TYPE_ENUM, TYPE_ENUM_ITEM, TYPE_FUNCTION}
local EXPECT_INSTANCE_OR_FUNCTION = {TYPE_INSTANCE, TYPE_FUNCTION}
local EXPECT_BOOLEAN_OR_FUNCTION = {TYPE_BOOLEAN, TYPE_FUNCTION}
local EXPECT_STRING_OR_FUNCTION = {TYPE_STRING, TYPE_FUNCTION}
local EXPECT_NUMBER_OR_FUNCTION = {TYPE_NUMBER, TYPE_FUNCTION}
local EXPECT_TABLE_OR_FUNCTION = {TYPE_TABLE, TYPE_FUNCTION}
local EXPECT_SOMETHING = {TYPE_SOMETHING}
local EXPECT_FUNCTION = {TYPE_FUNCTION}
local EXPECT_STRING = {TYPE_STRING}
local EXPECT_TABLE = {TYPE_TABLE}

--- This is only really for type checking internally for data passed to constraints and util functions
local function ExpectType<T>(PassedArg: T, ExpectedTypes: {string}, ArgKey: number | string)
    local GotType = typeof(PassedArg)
    local Satisfied = false

    for _, PossibleType in ExpectedTypes do
        if (GotType == PossibleType) then
            Satisfied = true
            break
        end
    end

    assert(Satisfied, INVALID_ARGUMENT:format(tostring(ArgKey), table.concat(ExpectedTypes, " or "), GotType))
end

local function CreateStandardInitial(ExpectedTypeName: string): ((...any) -> (boolean, string))
    return function(_, Item)
        local ItemType = typeof(Item)

        if (ItemType == ExpectedTypeName) then
            return true, EMPTY_STRING
        end

        return false, INVALID_TYPE:format(ExpectedTypeName, ItemType)
    end
end

local function ConcatWithToString<T>(Array: {T}, Separator: string): string
    local Result = EMPTY_STRING

    for _, Value in Array do
        Result ..= tostring(Value) .. Separator
    end

    return (#Array > 0 and Result:sub(1, #Result - #Separator) or Result)
end

local STRUCTURE_TO_FLAT_STRING_MT = {
    __tostring = function(self)
        local Pairings = {}

        for Key, Value in self do
            table.insert(Pairings, tostring(Key) .. " = " .. tostring(Value))
        end

        return "{" .. ConcatWithToString(Pairings, ", ") .. "}"
    end;
}

local WEAK_KEY_MT = {__mode = "k"}

-- Standard re-usable functions throughout all TypeCheckers
    local function IsAKeyIn(self, Store)
        ExpectType(Store, EXPECT_TABLE_OR_FUNCTION, 1)

        return self:_AddConstraint("IsAKeyIn", function(_, Key, Store)
            if (Store[Key] == nil) then
                return false, "Key " .. tostring(Key) .. " was not found in table: " .. tostring(Store)
            end

            return true, EMPTY_STRING
        end, Store)
    end

    local function IsAValueIn(self, Store)
        ExpectType(Store, EXPECT_TABLE_OR_FUNCTION, 1)

        return self:_AddConstraint("IsAValueIn", function(_, TargetValue, Store)
            for _, Value in Store do
                if (Value == TargetValue) then
                    return true, EMPTY_STRING
                end
            end

            return false, "Value " .. tostring(TargetValue) .. " was not found in table: " .. tostring(Store)
        end, Store)
    end

    local function Equals(self, ExpectedValue)
        return self:_AddConstraint("Equals", function(_, Value, ExpectedValue)
            if (Value == ExpectedValue) then
                return true, EMPTY_STRING
            end

            return false, "Value " .. tostring(Value) .. " does not equal " .. tostring(ExpectedValue)
        end, ExpectedValue)
    end

    local function GreaterThan(self, GTValue)
        return self:_AddConstraint("GreaterThan", function(_, Value, GTValue)
            if (Value > GTValue) then
                return true, EMPTY_STRING
            end

            return false, "Value " .. tostring(Value) .. " is not greater than " .. tostring(GTValue)
        end, GTValue)
    end

    local function LessThan(self, LTValue)
        return self:_AddConstraint("LessThan", function(_, Value, LTValue)
            if (Value < LTValue) then
                return true, EMPTY_STRING
            end

            return false, "Value " .. tostring(Value) .. " is not less than " .. tostring(LTValue)
        end, LTValue)
    end

    local function GreaterThanOrEqualTo(self, GTEValue)
        return self:_AddConstraint("GreaterThanOrEqualTo", function(_, Value, GTEValue)
            if (Value >= GTEValue) then
                return true, EMPTY_STRING
            end

            return false, "Value " .. tostring(Value) .. " is not greater than or equal to " .. tostring(GTEValue)
        end, GTEValue)
    end

    local function LessThanOrEqualTo(self, LTEValue)
        return self:_AddConstraint("LessThanOrEqualTo", function(_, Value, LTEValue)
            if (Value <= LTEValue) then
                return true, EMPTY_STRING
            end

            return false, "Value " .. tostring(Value) .. " is not less than or equal to " .. tostring(LTEValue)
        end, LTEValue)
    end




type SelfReturn<T, P...> = ((T, P...) -> T)

type TypeCheckerConstructor<T, P...> = ((P...) -> T)

type TypeChecker<T> = {
    Or: SelfReturn<T, TypeChecker<any> | () -> TypeChecker<any>>;
    And: SelfReturn<T, TypeChecker<any>>;
    Alias: SelfReturn<T, string>;
    Negate: SelfReturn<T>;
    Cached: SelfReturn<T>;
    Optional: SelfReturn<T>;
    WithContext: SelfReturn<T, any?>;
    FailMessage: SelfReturn<T, string>;

    WrapCheck: (T) -> ((any) -> (boolean, string));
    WrapAssert: (T) -> ((any) -> ());
    Check: (T, any) -> (string, boolean);
    Assert: (T, any) -> ();

    -- Standard constraints
    Equals: SelfReturn<T, any>;
    equals: SelfReturn<T, any>;

    IsAValueIn: SelfReturn<T, any>;
    isAValueIn: SelfReturn<T, any>;

    IsAKeyIn: SelfReturn<T, any>;
    isAKeyIn: SelfReturn<T, any>;

    GreaterThan: SelfReturn<T, number | (any?) -> number>;
    greaterThan: SelfReturn<T, number | (any?) -> number>;

    LessThan: SelfReturn<T, number | (any?) -> number>;
    lessThan: SelfReturn<T, number | (any?) -> number>;

    GreaterThanOrEqualTo: SelfReturn<T, number | (any?) -> number>;
    greaterThanOrEqualTo: SelfReturn<T, number | (any?) -> number>;

    LessThanOrEqualTo: SelfReturn<T, number | (any?) -> number>;
    lessThanOrEqualTo: SelfReturn<T, number | (any?) -> number>;
};

local RootContext -- Faster & easier just using one high scope variable which all TypeCheckers can access during checking time, than propogating the context downwards
local TypeGuard = {}

--- Creates a template TypeChecker object that can be used to extend behaviors via constraints
function TypeGuard.Template(Name: string)
    ExpectType(Name, EXPECT_STRING, 1)

    local TemplateClass = {}
    TemplateClass.__index = TemplateClass
    TemplateClass._InitialConstraints = nil
    TemplateClass._InitialConstraint = nil
    TemplateClass.IsTemplate = true
    TemplateClass.Type = Name

    function TemplateClass.new(...)
        local self = {
            _Tags = {};
            _Disjunction = {};
            _Conjunction = {};
            _ActiveConstraints = {};

            _LastConstraint = EMPTY_STRING;

            _Cache = nil;
            _Context = nil;
            _FailMessage = nil;
        }

        setmetatable(self, TemplateClass)

        local NumArgs = select("#", ...)

        -- Support for a single constraint passed as the constructor, with an arbitrary number of args
        local InitialConstraint = self._InitialConstraint

        if (InitialConstraint and NumArgs > 0) then
            return InitialConstraint(self, ...)
        end

        -- Multiple constraints support (but only ONE arg per constraint is supported currently)
        local InitialConstraints = TemplateClass._InitialConstraints

        if (InitialConstraints and NumArgs > 0) then
            for Index = 1, NumArgs do
                self = InitialConstraints[Index](self, select(Index, ...))
            end

            return self
        end

        return self
    end

    function TemplateClass:Copy()
        local New = TemplateClass.new()

        -- Copy tags
        for Key, Value in self._Tags do
            New._Tags[Key] = Value
        end

        -- Copy OR
        for Index, Disjunction in self._Disjunction do
            New._Disjunction[Index] = Disjunction
        end

        -- Copy AND
        for Index, Conjunction in self._Conjunction do
            New._Conjunction[Index] = Conjunction
        end

        -- Copy constraints
        for ConstraintName, Constraint in self._ActiveConstraints do
            New._ActiveConstraints[ConstraintName] = Constraint
        end

        New._Context = self._Context
        New._FailMessage = self._FailMessage
        New._LastConstraint = self._LastConstraint

        return New
    end
    TemplateClass.copy = TemplateClass.Copy

    --- Wraps & negates the last constraint (i.e. if it originally would fail, it passes, and vice versa)
    function TemplateClass:Negate()
        self = self:Copy()

        local LastConstraint = self._LastConstraint
        assert(LastConstraint ~= EMPTY_STRING, "Nothing to negate! (No constraints active)")
        self._ActiveConstraints[LastConstraint][4] = true

        return self
    end
    TemplateClass.negate = TemplateClass.Negate

    --- Sets a custom fail message to return if Check() fails
    function TemplateClass:FailMessage(Message: string)
        ExpectType(Message, EXPECT_STRING, 1)

        self = self:Copy()
        self._FailMessage = Message
        return self
    end
    TemplateClass.failMessage = TemplateClass.FailMessage

    function TemplateClass:Cached()
        return self:_AddTag("Cached")
    end
    TemplateClass.cached = TemplateClass.Cached

    function TemplateClass:_AddConstraint(ConstraintName, Constraint, ...)
        ExpectType(ConstraintName, EXPECT_STRING, 1)
        ExpectType(Constraint, EXPECT_FUNCTION, 2)

        self = self:Copy()
        self._LastConstraint = ConstraintName

        local Args = {...}
        local HasFunctions = false

        for _, Value in Args do
            local ArgType = typeof(Value)

            if (ArgType == TYPE_FUNCTION) then
                HasFunctions = true
                continue
            end
        end

        local ActiveConstraints = self._ActiveConstraints
        assert(ActiveConstraints[ConstraintName] == nil, "Constraint already exists: " .. ConstraintName)
        ActiveConstraints[ConstraintName] = {Constraint, Args, HasFunctions, false}
        return self
    end

    --- Adds a tag (for internal purposes)
    function TemplateClass:_AddTag(TagName)
        ExpectType(TagName, EXPECT_STRING, 1)
        assert(self._Tags[TagName] == nil, "Tag already exists: " .. TagName)

        self = self:Copy()
        self._Tags[TagName] = true
        return self
    end

    function TemplateClass:_GetCache()
        local Cache = self._Cache

        if (not Cache) then
            Cache = setmetatable({}, WEAK_KEY_MT); -- Weak keys because we don't want to leak Instances or tables
            self._Cache = Cache
        end

        return Cache
    end

    --- Checks if the value is of the correct type
    function TemplateClass:_Check(Value)
        debug.profilebegin(Name .. CHECK_TAG_SUFFIX)

        local Tags = self._Tags
        local CacheTag = Tags.Cached
        local Cache

        if (CacheTag) then
            Cache = self:_GetCache()

            local CacheValue = Cache[Value]

            if (CacheValue) then
                local Success = CacheValue[1]
                local Result = CacheValue[2]
                debug.profileend()
                return Success, Result
            end
        end

        -- Handle "type x or type y or type z ..."
        -- We do this before checking constraints to check if any of the other conditions succeed
        local Disjunctions = self._Disjunction
        local DidTryDisjunction = (Disjunctions[1] ~= nil)

        for _, AlternateType in Disjunctions do
            if (typeof(AlternateType) == TYPE_FUNCTION) then
                AlternateType = AlternateType(self)
            end

            local Success, _ = AlternateType:_Check(Value, RootContext)

            if (Success) then
                if (CacheTag) then
                    Cache[Value] = {true, EMPTY_STRING}
                end

                debug.profileend()
                return true, EMPTY_STRING
            end
        end

        -- Handle "type x and type y and type z ..." - this is only really useful for objects and arrays
        for _, Conjunction in self._Conjunction do
            local Success, Message = Conjunction:_Check(Value, RootContext)

            if (not Success) then
                local Result = self._FailMessage or ("[Conjunction " .. tostring(Conjunction) .. "] " .. Message)

                if (CacheTag) then
                    Cache[Value] = {false, Result}
                end

                debug.profileend()
                return false, Result
            end
        end

        -- Optional allows the value to be nil, in which case it won't be checked and we can resolve
        if (Tags.Optional and Value == nil) then
            if (CacheTag) then
                Cache[Value] = {true, EMPTY_STRING}
            end

            debug.profileend()
            return true, EMPTY_STRING
        end

        -- Handle initial type check
        local Success, Message = self:_Initial(Value)

        if (not Success) then
            if (DidTryDisjunction) then
                local Result = self._FailMessage or ("Disjunctions failed on " .. tostring(self))

                if (CacheTag) then
                    Cache[Value] = {false, Result}
                end

                debug.profileend()
                return false, Result
            else
                Message = self._FailMessage or Message

                if (CacheTag) then
                    Cache[Value] = {false, Message}
                end

                debug.profileend()
                return false, Message
            end
        end

        -- Handle active constraints
        for ConstraintName, Constraint in self._ActiveConstraints do
            local Call = Constraint[1]
            local Args = Constraint[2]
            local HasFunctionalParams = Constraint[3]
            local ShouldNegate = Constraint[4]

            -- Functional params -> transform into values when type checking
            if (HasFunctionalParams) then
                Args = table.clone(Args)

                for Index, Arg in Args do
                    if (typeof(Arg) == TYPE_FUNCTION) then
                        Args[Index] = Arg(RootContext)
                    end
                end
            end

            -- Call the constraint to verify it is satisfied
            local SubSuccess, SubMessage = Call(self, Value, unpack(Args))

            if (ShouldNegate) then
                SubMessage = if (SubSuccess) then
                                "Constraint '" .. ConstraintName .. "' succeeded but was expected to fail on value " .. tostring(Value)
                                else
                                EMPTY_STRING

                SubSuccess = not SubSuccess
            end

            if (not SubSuccess) then
                if (DidTryDisjunction) then
                    local Result = self._FailMessage or ("Disjunctions failed on " .. tostring(self))

                    if (CacheTag) then
                        Cache[Value] = {false, Result}
                    end

                    debug.profileend()
                    return false, Result
                else
                    SubMessage = self._FailMessage or SubMessage

                    if (CacheTag) then
                        Cache[Value] = {false, SubMessage}
                    end

                    debug.profileend()
                    return false, SubMessage
                end
            end
        end

        if (CacheTag) then
            Cache[Value] = {true, EMPTY_STRING}
        end

        debug.profileend()
        return true, EMPTY_STRING
    end

    --- Calling this will only check the type of the passed value if that value is not nil, i.e. it's an optional value so nothing can be passed, but if it is not nothing then it will be checked
    function TemplateClass:Optional()
        return self:_AddTag("Optional")
    end
    TemplateClass.optional = TemplateClass.Optional

    --- Enqueues a new constraint to satisfy 'or' i.e. "check x or check y or check z or ..." must pass
    function TemplateClass:Or(OtherType)
        if (typeof(OtherType) ~= TYPE_FUNCTION) then
            TypeGuard._AssertIsTypeBase(OtherType, 1)
        end

        self = self:Copy()
        table.insert(self._Disjunction, OtherType)
        return self
    end
    TemplateClass["or"] = TemplateClass.Or

    --- Enqueues a new constraint to satisfy 'and' i.e. "check x and check y and check z and ..." must pass
    function TemplateClass:And(OtherType)
        TypeGuard._AssertIsTypeBase(OtherType, 1)

        self = self:Copy()
        table.insert(self._Conjunction, OtherType)
        return self
    end
    TemplateClass["and"] = TemplateClass.And

    --- Creates an Alias - useful for replacing large "Or" chains in big structures to identify where it is failing
    function TemplateClass:Alias(AliasName)
        ExpectType(AliasName, EXPECT_STRING, 1)

        self = self:Copy()
        self._Alias = AliasName
        return self
    end
    TemplateClass.alias = TemplateClass.Alias

    --- Passes down a "context" value to constraints with functional values
    --- We don't copy here because performance is important at the checking phase
    function TemplateClass:WithContext(Context)
        self._Context = Context
        return self
    end
    TemplateClass.withContext = TemplateClass.WithContext

    --- Wrap Check into its own callable function
    function TemplateClass:WrapCheck()
        return function(Value)
            return self:_Check(Value)
        end
    end
    TemplateClass.wrapCheck = TemplateClass.WrapCheck

    --- Wraps Assert into its own callable function
    function TemplateClass:WrapAssert()
        return function(Value)
            return self:Assert(Value)
        end
    end
    TemplateClass.wrapAssert = TemplateClass.WrapAssert

    --- Check (like above) except sets a universal context for the duration of the check
    function TemplateClass:Check(Value)
        RootContext = self._Context
        local Success, Result = self:_Check(Value)
        RootContext = nil
        return Success, Result
    end
    TemplateClass.check = TemplateClass.Check

    --- Throws an error if the check is unsatisfied
    function TemplateClass:Assert(Value)
        assert(self:Check(Value))
    end
    TemplateClass.assert = TemplateClass.Assert

    function TemplateClass:__tostring()
        -- User can create a unique alias to help simplify "where did it fail?"
        if (self._Alias) then
            return self._Alias
        end

        local Fields = {}

        -- Constraints list (including arg, possibly other type defs)
        if (next(self._ActiveConstraints) ~= nil) then
            local InnerConstraints = {}

            for ConstraintName, Constraint in self._ActiveConstraints do
                table.insert(InnerConstraints, ConstraintName .. "(" .. ConcatWithToString(Constraint[2], ", ") .. ")")
            end

            table.insert(Fields, "Constraints = {" .. ConcatWithToString(InnerConstraints, ", ") .. "}")
        end

        -- Alternatives field str
        if (#self._Disjunction > 0) then
            local Alternatives = {}

            for _, AlternateType in self._Disjunction do
                table.insert(Alternatives, tostring(AlternateType))
            end

            table.insert(Fields, "Or = {" .. ConcatWithToString(Alternatives, ", ") .. "}")
        end

        -- Union fields str
        if (#self._Conjunction > 0) then
            local Unions = {}

            for _, Union in self._Conjunction do
                table.insert(Unions, tostring(Union))
            end

            table.insert(Fields, "And = {" .. ConcatWithToString(Unions, ", ") .. "}")
        end

        -- Tags (e.g. Optional, Strict)
        if (next(self._Tags) ~= nil) then
            local Tags = {}

            for Tag in self._Tags do
                table.insert(Tags, Tag)
            end

            table.insert(Fields, "Tags = {" .. ConcatWithToString(Tags, ", ") .. "}")
        end

        if (self._Context) then
            table.insert(Fields, "Context = " .. tostring(self._Context))
        end

        return self.Type .. "(" .. ConcatWithToString(Fields, ", ") .. ")"
    end

    TemplateClass.Equals = Equals
    TemplateClass.equals = Equals

    TemplateClass.IsAValueIn = IsAValueIn
    TemplateClass.isAValueIn = IsAValueIn

    TemplateClass.IsAKeyIn = IsAKeyIn
    TemplateClass.isAKeyIn = IsAKeyIn

    TemplateClass.GreaterThan = GreaterThan
    TemplateClass.greaterThan = GreaterThan

    TemplateClass.LessThan = LessThan
    TemplateClass.lessThan = LessThan

    TemplateClass.GreaterThanOrEqualTo = GreaterThanOrEqualTo
    TemplateClass.greaterThanOrEqualTo = GreaterThanOrEqualTo

    TemplateClass.LessThanOrEqualTo = LessThanOrEqualTo
    TemplateClass.lessThanOrEqualTo = LessThanOrEqualTo

    return function(...)
        return TemplateClass.new(...)
    end, TemplateClass
end

--- Checks if an object contains the fields which define a type template from this module
function TypeGuard._AssertIsTypeBase(Subject: any, Position: number | string)
    ExpectType(Subject, EXPECT_TABLE, Position)

    assert(Subject.IsTemplate, "Subject is not a type template")
end

--- Cheap & easy way to create a type without any constraints, and just an initial check corresponding to Roblox's typeof
function TypeGuard.FromTypeName(TypeName: string)
    ExpectType(TypeName, EXPECT_STRING, 1)

    local CheckerFunction, CheckerClass = TypeGuard.Template(TypeName)
    CheckerClass._Initial = CreateStandardInitial(TypeName)

    type CustomTypeChecker = TypeChecker<CustomTypeChecker> & {}
    return CheckerFunction :: TypeCheckerConstructor<CustomTypeChecker>
end
TypeGuard.fromTypeName = TypeGuard.FromTypeName




do
    type NumberTypeChecker = TypeChecker<NumberTypeChecker> & {
        Integer: SelfReturn<NumberTypeChecker>;
        integer: SelfReturn<NumberTypeChecker>;

        Decimal: SelfReturn<NumberTypeChecker>;
        decimal: SelfReturn<NumberTypeChecker>;

        RangeInclusive: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;
        rangeInclusive: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;

        RangeExclusive: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;
        rangeExclusive: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;

        Positive: SelfReturn<NumberTypeChecker>;
        positive: SelfReturn<NumberTypeChecker>;

        Negative: SelfReturn<NumberTypeChecker>;
        negative: SelfReturn<NumberTypeChecker>;

        IsNaN: SelfReturn<NumberTypeChecker>;
        isNan: SelfReturn<NumberTypeChecker>;

        IsInfinite: SelfReturn<NumberTypeChecker>;
        isInfinite: SelfReturn<NumberTypeChecker>;

        IsClose: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;
        isClose: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;
    };

    local Number: TypeCheckerConstructor<NumberTypeChecker, TypeChecker<any>?>, NumberClass = TypeGuard.Template("Number")
    NumberClass._Initial = CreateStandardInitial(TYPE_NUMBER)

    --- Checks if the value is whole
    function NumberClass:Integer()
        return self:_AddConstraint("Integer", function(_, Item)
            if (Item % 1 == 0) then
                return true, EMPTY_STRING
            end

            return false, "Expected integer form, got " .. tostring(Item)
        end)
    end
    NumberClass.integer = NumberClass.Integer

    --- Checks if the number is a decimal
    function NumberClass:Decimal()
        return self:_AddConstraint("Decimal", function(_, Item)
            if (Item % 1 ~= 0) then
                return true, EMPTY_STRING
            end

            return false, "Expected decimal form, got " .. tostring(Item)
        end)
    end
    NumberClass.decimal = NumberClass.Decimal

    --- Ensures a number is between or equal to a minimum and maxmimu value
    function NumberClass:RangeInclusive(Min, Max)
        ExpectType(Min, EXPECT_NUMBER_OR_FUNCTION, 1)
        ExpectType(Max, EXPECT_NUMBER_OR_FUNCTION, 2)

        return self:GreaterThanOrEqualTo(Min):LessThanOrEqualTo(Max)
    end
    NumberClass.rangeInclusive = NumberClass.RangeInclusive

    --- Ensures a number is between but not equal to a minimum and maximum value
    function NumberClass:RangeExclusive(Min, Max)
        return self:GreaterThan(Min):LessThan(Max)
    end
    NumberClass.rangeExclusive = NumberClass.RangeExclusive

    --- Checks the number is positive
    function NumberClass:Positive()
        return self:_AddConstraint("Positive", function(_, Item)
            if (Item < 0) then
                return false, "Expected positive number, got " .. tostring(Item)
            end

            return true, EMPTY_STRING
        end)
    end
    NumberClass.positive = NumberClass.Positive

    --- Checks the number is negative
    function NumberClass:Negative()
        return self:_AddConstraint("Negative", function(_, Item)
            if (Item >= 0) then
                return false, "Expected negative number, got " .. tostring(Item)
            end

            return true, EMPTY_STRING
        end)
    end
    NumberClass.negative = NumberClass.Negative

    --- Checks if the number is NaN
    function NumberClass:IsNaN()
        return self:_AddConstraint("IsNaN", function(_, Item)
            if (Item ~= Item) then
                return true, EMPTY_STRING
            end

            return false, "Expected NaN, got " .. tostring(Item)
        end)
    end
    NumberClass.isNaN = NumberClass.IsNaN

    --- Checks if the number is infinite
    function NumberClass:IsInfinite()
        return self:_AddConstraint("IsInfinite", function(_, Item)
            if (Item == math.huge or Item == -math.huge) then
                return true, EMPTY_STRING
            end

            return false, "Expected infinite, got " .. tostring(Item)
        end)
    end
    NumberClass.isInfinite = NumberClass.IsInfinite

    --- Checks if the number is close to another
    function NumberClass:IsClose(CloseTo, Tolerance)
        ExpectType(CloseTo, EXPECT_NUMBER_OR_FUNCTION, 1)
        Tolerance = Tolerance or 0.00001

        return self:_AddConstraint("IsClose", function(_, NumberValue, CloseTo, Tolerance)
            if (math.abs(NumberValue - CloseTo) < Tolerance) then
                return true, EMPTY_STRING
            end

            return false, "Expected " .. tostring(CloseTo) .. " +/- " .. tostring(Tolerance) .. ", got " .. tostring(NumberValue)
        end, CloseTo, Tolerance)
    end

    TypeGuard.Number = Number
    TypeGuard.number = Number
end




do
    type StringTypeChecker = TypeChecker<StringTypeChecker> & {
        MinLength: SelfReturn<StringTypeChecker, number | (any?) -> number>;
        minLength: SelfReturn<StringTypeChecker, number | (any?) -> number>;

        MaxLength: SelfReturn<StringTypeChecker, number | (any?) -> number>;
        maxLength: SelfReturn<StringTypeChecker, number | (any?) -> number>;

        Pattern: SelfReturn<StringTypeChecker, string | (any?) -> string>;
        pattern: SelfReturn<StringTypeChecker, string | (any?) -> string>;

        Contains: SelfReturn<StringTypeChecker, string | (any?) -> string>;
        contains: SelfReturn<StringTypeChecker, string | (any?) -> string>;
    };

    local String: TypeCheckerConstructor<StringTypeChecker, TypeChecker<any>?>, StringClass = TypeGuard.Template("String")
    StringClass._Initial = CreateStandardInitial(TYPE_STRING)

    --- Ensures a string is at least a certain length
    function StringClass:MinLength(MinLength)
        ExpectType(MinLength, EXPECT_NUMBER_OR_FUNCTION, 1)

        return self:_AddConstraint("MinLength", function(_, Item, MinLength)
            if (#Item < MinLength) then
                return false, "Length must be at least " .. MinLength .. ", got " .. #Item
            end

            return true, EMPTY_STRING
        end, MinLength)
    end
    StringClass.minLength = StringClass.MinLength

    --- Ensures a string is at most a certain length
    function StringClass:MaxLength(MaxLength)
        ExpectType(MaxLength, EXPECT_NUMBER_OR_FUNCTION, 1)

        return self:_AddConstraint("MaxLength", function(_, Item, MaxLength)
            if (#Item > MaxLength) then
                return false, "Length must be at most " .. MaxLength .. ", got " .. #Item
            end

            return true, EMPTY_STRING
        end, MaxLength)
    end
    StringClass.maxLength = StringClass.MaxLength

    --- Ensures a string matches a pattern
    function StringClass:Pattern(PatternString)
        ExpectType(PatternString, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("Pattern", function(_, Item, Pattern)
            if (string.match(Item, Pattern) ~= Item) then
                return false, "String does not match pattern " .. tostring(Pattern)
            end

            return true, EMPTY_STRING
        end, PatternString)
    end
    StringClass.pattern = StringClass.Pattern

    --- Ensures a string contains a certain substring
    function StringClass:Contains(SubstringValue)
        ExpectType(SubstringValue, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("Contains", function(_, Item, Substring)
            if (string.find(Item, Substring) == nil) then
                return false, "String does not contain substring " .. tostring(Substring)
            end

            return true, EMPTY_STRING
        end, SubstringValue)
    end

    TypeGuard.String = String
    TypeGuard.string = String
end




do
    local PREFIX_ARRAY = "Index "
    local PREFIX_PARAM = "Param #"
    local ERR_PREFIX = "[%s%d] "
    local ERR_UNEXPECTED_VALUE = ERR_PREFIX .. " Unexpected value (strict tag is present)"

    type ArrayTypeChecker = TypeChecker<ArrayTypeChecker> & {
        OfLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;
        ofLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;

        MinLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;
        minLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;

        MaxLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;
        maxLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;

        Contains: SelfReturn<ArrayTypeChecker, any>;
        contains: SelfReturn<ArrayTypeChecker, any>;

        OfType: SelfReturn<ArrayTypeChecker, TypeChecker<any>>;
        ofType: SelfReturn<ArrayTypeChecker, TypeChecker<any>>;

        OfStructure: SelfReturn<ArrayTypeChecker, {TypeChecker<any>}>;
        ofStructure: SelfReturn<ArrayTypeChecker, {TypeChecker<any>}>;

        StructuralEquals: SelfReturn<ArrayTypeChecker, {TypeChecker<any>}>;
        structuralEquals: SelfReturn<ArrayTypeChecker, {TypeChecker<any>}>;

        Strict: SelfReturn<ArrayTypeChecker>;
        strict: SelfReturn<ArrayTypeChecker>;

        DenoteParams: SelfReturn<ArrayTypeChecker>;
        denoteParams: SelfReturn<ArrayTypeChecker>;

        IsFrozen: SelfReturn<ArrayTypeChecker>;
        isFrozen: SelfReturn<ArrayTypeChecker>;

        IsOrdered: SelfReturn<ArrayTypeChecker, boolean | (any?) -> boolean>;
        isOrdered: SelfReturn<ArrayTypeChecker, boolean | (any?) -> boolean>;
    };

    local Array: TypeCheckerConstructor<ArrayTypeChecker, TypeChecker<any>?>, ArrayClass = TypeGuard.Template("Array")

    function ArrayClass:_PrefixError(ErrorString: string, Index: number)
        return ErrorString:format((self._Tags.DenoteParams and PREFIX_PARAM or PREFIX_ARRAY), Index)
    end

    function ArrayClass:_Initial(TargetArray)
        if (typeof(TargetArray) ~= TYPE_TABLE) then
            return false, "Expected table, got " .. typeof(TargetArray)
        end

        for Key in TargetArray do
            local KeyType = typeof(Key)

            if (KeyType ~= TYPE_NUMBER) then
                return false, "Non-numetic key detected: " .. KeyType
            end
        end

        return true, EMPTY_STRING
    end

    --- Ensures an array is of a certain length
    function ArrayClass:OfLength(Length)
        ExpectType(Length, EXPECT_NUMBER_OR_FUNCTION, 1)

        return self:_AddConstraint("Length", function(_, TargetArray, Length)
            if (#TargetArray ~= Length) then
                return false, "Length must be " .. Length .. ", got " .. #TargetArray
            end

            return true, EMPTY_STRING
        end, Length)
    end
    ArrayClass.ofLength = ArrayClass.OfLength

    --- Ensures an array is at least a certain length
    function ArrayClass:MinLength(MinLength)
        ExpectType(MinLength, EXPECT_NUMBER_OR_FUNCTION, 1)

        return self:_AddConstraint("MinLength", function(_, TargetArray, MinLength)
            if (#TargetArray < MinLength) then
                return false, "Length must be at least " .. MinLength .. ", got " .. #TargetArray
            end

            return true, EMPTY_STRING
        end, MinLength)
    end
    ArrayClass.minLength = ArrayClass.MinLength

    --- Ensures an array is at most a certain length
    function ArrayClass:MaxLength(MaxLength)
        ExpectType(MaxLength, EXPECT_NUMBER_OR_FUNCTION, 1)

        return self:_AddConstraint("MaxLength", function(_, TargetArray, MaxLength)
            if (#TargetArray > MaxLength) then
                return false, "Length must be at most " .. MaxLength .. ", got " .. #TargetArray
            end

            return true, EMPTY_STRING
        end, MaxLength)
    end
    ArrayClass.maxLength = ArrayClass.MaxLength

    --- Ensures an array contains some given value
    function ArrayClass:Contains(Value, StartPoint)
        if (Value == nil) then
            ExpectType(Value, EXPECT_SOMETHING, 1)
        end

        if (StartPoint) then
            ExpectType(StartPoint, EXPECT_NUMBER_OR_FUNCTION, 2)
        end

        return self:_AddConstraint("Contains", function(_, TargetArray, Value, StartPoint)
            if (table.find(TargetArray, Value, StartPoint) == nil) then
                return false, "Value not found in array: " .. tostring(Value)
            end

            return true, EMPTY_STRING
        end, Value, StartPoint)
    end
    ArrayClass.contains = ArrayClass.Contains

    --- Ensures each value in the template array satisfies the passed TypeChecker
    function ArrayClass:OfType(SubType)
        TypeGuard._AssertIsTypeBase(SubType, 1)

        return self:_AddConstraint("OfType", function(SelfRef, TargetArray, SubType)
            for Index, Value in TargetArray do
                local Success, SubMessage = SubType:_Check(Value)

                if (not Success) then
                    return false, ERR_PREFIX:format((SelfRef._Tags.DenoteParams and PREFIX_PARAM or PREFIX_ARRAY), tostring(Index)) .. SubMessage
                end
            end

            return true, EMPTY_STRING
        end, SubType)
    end
    ArrayClass.ofType = ArrayClass.OfType

    -- Takes an array of types and checks it against the passed array
    function ArrayClass:OfStructure(SubTypesAtPositions)
        ExpectType(SubTypesAtPositions, EXPECT_TABLE, 1)

        -- Just in case the user does any weird mutation
        local SubTypesCopy = table.create(#SubTypesAtPositions)

        for Index, Value in SubTypesAtPositions do
            TypeGuard._AssertIsTypeBase(Value, Index)
            SubTypesCopy[Index] = Value
        end

        setmetatable(SubTypesCopy, STRUCTURE_TO_FLAT_STRING_MT)

        return self:_AddConstraint("OfStructure", function(SelfRef, TargetArray, SubTypesAtPositions)
            -- Check all fields which should be in the object exist (unless optional) and the type check for each passes
            for Index, Checker in SubTypesAtPositions do
                local Success, SubMessage = Checker:_Check(TargetArray[Index])

                if (not Success) then
                    return false, SelfRef:_PrefixError(ERR_PREFIX, tostring(Index)) .. SubMessage
                end
            end

            -- Check there are no extra indexes which shouldn't be in the object
            if (SelfRef._Tags.Strict) then
                for Index in TargetArray do
                    local Checker = SubTypesAtPositions[Index]

                    if (not Checker) then
                        return false, SelfRef:_PrefixError(ERR_UNEXPECTED_VALUE, tostring(Index))
                    end
                end
            end

            return true, EMPTY_STRING
        end, SubTypesCopy, SubTypesAtPositions)
    end
    ArrayClass.ofStructure = ArrayClass.OfStructure

    --- OfStructure but strict
    function ArrayClass:StructuralEquals(Other)
        return self:OfStructure(Other):Strict()
    end
    ArrayClass.structuralEquals = ArrayClass.StructuralEquals

    --- Tags this ArrayTypeChecker as strict i.e. no extra indexes allowed in OfStructure constraint
    function ArrayClass:Strict()
        return self:_AddTag("Strict")
    end
    ArrayClass.strict = ArrayClass.Strict

    --- Tags this ArrayTypeChecker as a params call (just for better information when using TypeGuard.Params)
    function ArrayClass:DenoteParams()
        return self:_AddTag("DenoteParams")
    end
    ArrayClass.denoteParams = ArrayClass.DenoteParams

    --- Checks if an array is frozen
    function ArrayClass:IsFrozen()
        return self:_AddConstraint("IsFrozen", function(_, TargetArray)
            if (table.isfrozen(TargetArray)) then
                return true, EMPTY_STRING
            end

            return false, "Table was not frozen"
        end)
    end
    ArrayClass.isFrozen = ArrayClass.IsFrozen

    --- Checks if an array is ordered
    --- @TODO If 'Descending' = false, assume ascending, but if 'Descending' = nil, assume ascending or descending from first 2 items in the array (accept ordering either way)
    function ArrayClass:IsOrdered(Descending)
        if (Descending ~= nil) then
            ExpectType(Descending, EXPECT_BOOLEAN_OR_FUNCTION, 1)
        end

        return self:_AddConstraint("IsOrdered", function(_, TargetArray, Descending)
            local Ascending = not Descending
            local Size = #TargetArray

            if (Size == 1) then
                return true, EMPTY_STRING
            end

            local Last = TargetArray[1]

            for Index = 2, Size do
                local Current = TargetArray[Index]

                if (Descending and Last < Current) then
                    return false, "Array is not ordered descending at index " .. Index
                elseif (Ascending and Last > Current) then
                    return false, "Array is not ordered ascending at index " .. Index
                end

                Last = Current
            end

            return true, EMPTY_STRING
        end, Descending)
    end
    ArrayClass.isOrdered = ArrayClass.IsOrdered

    ArrayClass._InitialConstraint = ArrayClass.OfType

    TypeGuard.Array = Array
end




do
    type ObjectTypeChecker = TypeChecker<ObjectTypeChecker> & {
        OfStructure: SelfReturn<ObjectTypeChecker, {[any]: TypeChecker<any>}>;
        ofStructure: SelfReturn<ObjectTypeChecker, {[any]: TypeChecker<any>}>;

        StructuralEquals: SelfReturn<ObjectTypeChecker, {[any]: TypeChecker<any>}>;
        structuralEquals: SelfReturn<ObjectTypeChecker, {[any]: TypeChecker<any>}>;

        Strict: SelfReturn<ObjectTypeChecker>;
        strict: SelfReturn<ObjectTypeChecker>;

        OfValueType: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;
        ofValueType: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;

        OfKeyType: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;
        ofKeyType: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;

        IsFrozen: SelfReturn<ObjectTypeChecker>;
        isFrozen: SelfReturn<ObjectTypeChecker>;

        CheckMetatable: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;
        checkMetatable: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;
    };

    local Object: TypeCheckerConstructor<ObjectTypeChecker, {[any]: TypeChecker<any>}?>, ObjectClass = TypeGuard.Template("Object")

    function ObjectClass:_Initial(TargetObject)
        if (typeof(TargetObject) ~= TYPE_TABLE) then
            return false, "Expected table, got " .. typeof(TargetObject)
        end

        for Key in TargetObject do
            if (typeof(Key) == TYPE_NUMBER) then
                return false, "Incorrect key type: number"
            end
        end

        return true, EMPTY_STRING
    end

    --- Ensures every key that exists in the subject also exists in the structure passed, optionally strict i.e. no extra key-value pairs
    function ObjectClass:OfStructure(OriginalSubTypes)
        ExpectType(OriginalSubTypes, EXPECT_TABLE, 1)

        -- Just in case the user does any weird mutation
        local SubTypesCopy = {}

        for Index, Value in OriginalSubTypes do
            TypeGuard._AssertIsTypeBase(Value, Index)
            SubTypesCopy[Index] = Value
        end

        setmetatable(SubTypesCopy, STRUCTURE_TO_FLAT_STRING_MT)

        return self:_AddConstraint("OfStructure", function(SelfRef, StructureCopy, SubTypes)
            -- Check all fields which should be in the object exist (unless optional) and the type check for each passes
            for Key, Checker in SubTypes do
                local RespectiveValue = StructureCopy[Key]

                if (RespectiveValue == nil and not Checker._Tags.Optional) then
                    return false, "[Key '" .. tostring(Key) .. "'] is nil"
                end

                local Success, SubMessage = Checker:_Check(RespectiveValue)

                if (not Success) then
                    return false, "[Key '" .. tostring(Key) .. "'] " .. SubMessage
                end
            end

            -- Check there are no extra fields which shouldn't be in the object
            if (SelfRef._Tags.Strict) then
                for Key in StructureCopy do
                    local Checker = SubTypes[Key]

                    if (not Checker) then
                        return false, "[Key '" .. tostring(Key) .. "'] unexpected (strict)"
                    end
                end
            end

            return true, EMPTY_STRING
        end, SubTypesCopy)
    end
    ObjectClass.ofStructure = ObjectClass.OfStructure

    --- For all values in the passed table, they must satisfy the TypeChecker passed to this constraint
    function ObjectClass:OfValueType(SubType)
        TypeGuard._AssertIsTypeBase(SubType, 1)

        return self:_AddConstraint("OfValueType", function(_, TargetArray, SubType)
            for Index, Value in TargetArray do
                local Success, SubMessage = SubType:_Check(Value)

                if (not Success) then
                    return false, "[OfValueType: Key '" .. tostring(Index) .. "'] " .. SubMessage
                end
            end

            return true, EMPTY_STRING
        end, SubType)
    end
    ObjectClass.ofValueType = ObjectClass.OfValueType

    --- For all keys in the passed table, they must satisfy the TypeChecker passed to this constraint
    function ObjectClass:OfKeyType(SubType)
        TypeGuard._AssertIsTypeBase(SubType, 1)

        return self:_AddConstraint("OfKeyType", function(_, TargetArray, SubType)
            for Key in TargetArray do
                local Success, SubMessage = SubType:_Check(Key)

                if (not Success) then
                    return false, "[OfKeyType: Key '" .. tostring(Key) .. "'] " .. SubMessage
                end
            end

            return true, EMPTY_STRING
        end, SubType)
    end
    ObjectClass.ofKeyType = ObjectClass.OfKeyType

    --- Strict i.e. no extra key-value pairs than what is explicitly specified when using OfStructure
    function ObjectClass:Strict()
        return self:_AddTag("Strict")
    end
    ObjectClass.strict = ObjectClass.Strict

    --- OfStructure but strict
    function ObjectClass:StructuralEquals(Structure)
        return self:OfStructure(Structure):Strict()
    end
    ObjectClass.structuralEquals = ObjectClass.StructuralEquals

    --- Checks if an object is frozen
    function ObjectClass:IsFrozen()
        return self:_AddConstraint("IsFrozen", function(_, TargetObject)
            if (table.isfrozen(TargetObject)) then
                return true, EMPTY_STRING
            end

            return false, "Table was not frozen"
        end)
    end
    ObjectClass.isFrozen = ObjectClass.IsFrozen

    --- Checks an object's metatable
    function ObjectClass:CheckMetatable(Checker)
        TypeGuard._AssertIsTypeBase(Checker, 1)

        return self:_AddConstraint("CheckMetatable", function(_, TargetObject, Checker)
            local Success, Message = Checker:Check(getmetatable(TargetObject))
            return Success, "[Metatable] " .. Message
        end, Checker)
    end
    ObjectClass.checkMetatable = ObjectClass.CheckMetatable

    ObjectClass._InitialConstraint = ObjectClass.OfStructure

    TypeGuard.Object = Object
end




do
    type InstanceTypeChecker = TypeChecker<InstanceTypeChecker> & {
        OfStructure: SelfReturn<InstanceTypeChecker, {[any]: TypeChecker<Instance>}>;
        ofStructure: SelfReturn<InstanceTypeChecker, {[any]: TypeChecker<Instance>}>;

        StructuralEquals: SelfReturn<InstanceTypeChecker, {[any]: TypeChecker<Instance>}>;
        structuralEquals: SelfReturn<InstanceTypeChecker, {[any]: TypeChecker<Instance>}>;

        IsA: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;
        isA: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;

        Strict: SelfReturn<InstanceTypeChecker>;
        strict: SelfReturn<InstanceTypeChecker>;

        HasTag: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;
        hasTag: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;

        IsDescendantOf: SelfReturn<InstanceTypeChecker, Instance | (any?) -> Instance>;
        isDescendantOf: SelfReturn<InstanceTypeChecker, Instance | (any?) -> Instance>;

        IsAncestorOf: SelfReturn<InstanceTypeChecker, Instance | (any?) -> Instance>;
        isAncestorOf: SelfReturn<InstanceTypeChecker, Instance | (any?) -> Instance>;

        HasAttribute: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;
        hasAttribute: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;

        CheckAttribute: SelfReturn<InstanceTypeChecker, string, TypeChecker<any>>;
        checkAttribute: SelfReturn<InstanceTypeChecker, string, TypeChecker<any>>;
    };

    local function Get(Inst, Key)
        return Inst[Key]
    end

    local function TryGet(Inst, Key)
        local Success, Result = pcall(Get, Inst, Key)

        if (Success) then
            return Result
        end

        return nil
    end

    local InstanceChecker: TypeCheckerConstructor<InstanceTypeChecker, string | (any?) -> string | nil, {[string]: TypeChecker<any>}?>, InstanceCheckerClass = TypeGuard.Template("Instance")
    InstanceCheckerClass._Initial = CreateStandardInitial(TYPE_INSTANCE)

    --- Ensures that an Instance has specific children and/or properties
    function InstanceCheckerClass:OfStructure(OriginalSubTypes)
        ExpectType(OriginalSubTypes, EXPECT_TABLE, 1)

        -- Just in case the user does any weird mutation
        local SubTypesCopy = {}

        for Key, Value in OriginalSubTypes do
            TypeGuard._AssertIsTypeBase(Value, Key)
            SubTypesCopy[Key] = Value
        end

        setmetatable(SubTypesCopy, STRUCTURE_TO_FLAT_STRING_MT)

        return self:_AddConstraint("OfStructure", function(SelfRef, InstanceRoot, SubTypes)
            -- Check all properties and children which should be in the Instance exist (unless optional) and the type check for each passes
            for Key, Checker in SubTypes do
                local Value = TryGet(InstanceRoot, Key)
                local Success, SubMessage = Checker:_Check(Value)

                if (not Success) then
                    return false, (typeof(Value) == TYPE_INSTANCE and "[Instance '" or "[Property '") .. tostring(Key) .. "'] " .. SubMessage
                end
            end

            -- Check there are no extra children which shouldn't be in the Instance
            if (SelfRef._Tags.Strict) then
                for _, Value in InstanceRoot:GetChildren() do
                    local Key = Value.Name
                    local Checker = SubTypes[Key]

                    if (not Checker) then
                        return false, "[Instance '" .. tostring(Key) .. "'] unexpected (strict)"
                    end
                end
            end

            return true, EMPTY_STRING
        end, SubTypesCopy)
    end
    InstanceCheckerClass.ofStructure = InstanceCheckerClass.OfStructur

    --- Uses Instance.IsA to assert the type of an Instance
    function InstanceCheckerClass:IsA(InstanceIsA)
        ExpectType(InstanceIsA, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("IsA", function(_, InstanceRoot, InstanceIsA)
            if (not InstanceRoot:IsA(InstanceIsA)) then
                return false, "Expected " .. InstanceIsA .. ", got " .. InstanceRoot.ClassName
            end

            return true, EMPTY_STRING
        end, InstanceIsA)
    end
    InstanceCheckerClass.isA = InstanceCheckerClass.IsA

    --- Activates strict tag for OfStructure
    function InstanceCheckerClass:Strict()
        return self:_AddTag("Strict")
    end
    InstanceCheckerClass.strict = InstanceCheckerClass.Strict

    --- OfStructure + strict tag i.e. no extra children exist beyond what is specified
    function InstanceCheckerClass:StructuralEquals(Structure)
        return self:OfStructure(Structure):Strict()
    end
    InstanceCheckerClass.structuralEquals = InstanceCheckerClass.StructuralEquals

    --- Checks if an Instance has a particular tag
    function InstanceCheckerClass:HasTag(Tag: string)
        ExpectType(Tag, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("HasTag", function(_, InstanceRoot, Tag)
            if (CollectionService:HasTag(InstanceRoot, Tag)) then
                return true, EMPTY_STRING
            end

            return false, "Expected tag '" .. Tag .. "' on Instance " .. InstanceRoot:GetFullName()
        end, Tag)
    end
    InstanceCheckerClass.hasTag = InstanceCheckerClass.HasTag

    --- Checks if an Instance has a particular attribute
    function InstanceCheckerClass:HasAttribute(Attribute: string)
        ExpectType(Attribute, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("HasAttribute", function(_, InstanceRoot, Attribute)
            if (InstanceRoot:GetAttribute(Attribute) ~= nil) then
                return true, EMPTY_STRING
            end

            return false, "Expected attribute '" .. Attribute .. "' to exist on Instance " .. InstanceRoot:GetFullName()
        end, Attribute)
    end
    InstanceCheckerClass.hasAttribute = InstanceCheckerClass.HasAttribute

    --- Applies a TypeChecker to an Instance's expected attribute
    function InstanceCheckerClass:CheckAttribute(Attribute: string, Checker: TypeChecker<any>)
        ExpectType(Attribute, EXPECT_STRING_OR_FUNCTION, 1)
        TypeGuard._AssertIsTypeBase(Checker, 2)

        return self:_AddConstraint("CheckAttribute", function(_, InstanceRoot, Attribute)
            local Success, SubMessage = Checker:_Check(InstanceRoot:GetAttribute(Attribute))

            if (not Success) then
                return false, "Attribute '" .. Attribute .. "' not satisfied on Instance " .. InstanceRoot:GetFullName() .. ": " .. SubMessage
            end

            return true, EMPTY_STRING
        end, Attribute, Checker)
    end
    InstanceCheckerClass.checkAttribute = InstanceCheckerClass.CheckAttribute

    --- Checks if an Instance is a descendant of a particular Instance
    function InstanceCheckerClass:IsDescendantOf(Instance)
        ExpectType(Instance, EXPECT_INSTANCE_OR_FUNCTION, 1)

        return self:_AddConstraint("IsDescendantOf", function(_, SubjectInstance, Instance)
            if (SubjectInstance:IsDescendantOf(Instance)) then
                return true, EMPTY_STRING
            end

            return false, "Expected Instance " .. SubjectInstance:GetFullName() .. " to be a descendant of " .. Instance:GetFullName()
        end, Instance)
    end
    InstanceCheckerClass.isDescendantOf = InstanceCheckerClass.IsDescendantOf

    --- Checks if an Instance is an ancestor of a particular Instance
    function InstanceCheckerClass:IsAncestorOf(Instance)
        ExpectType(Instance, EXPECT_INSTANCE_OR_FUNCTION, 1)

        return self:_AddConstraint("IsAncestorOf", function(_, SubjectInstance, Instance)
            if (SubjectInstance:IsAncestorOf(Instance)) then
                return true, EMPTY_STRING
            end

            return false, "Expected Instance " .. SubjectInstance:GetFullName() .. " to be an ancestor of " .. Instance:GetFullName()
        end, Instance)
    end
    InstanceCheckerClass.isAncestorOf = InstanceCheckerClass.IsAncestorOf

    InstanceCheckerClass._InitialConstraints = {InstanceCheckerClass.IsA, InstanceCheckerClass.OfStructure}

    TypeGuard.Instance = InstanceChecker
end




do
    type BooleanTypeChecker = TypeChecker<BooleanTypeChecker> & {};

    local Boolean: TypeCheckerConstructor<BooleanTypeChecker, boolean?>, BooleanClass = TypeGuard.Template("Boolean")
    BooleanClass._Initial = CreateStandardInitial(TYPE_BOOLEAN)

    BooleanClass._InitialConstraint = BooleanClass.Equals

    TypeGuard.Boolean = Boolean
    TypeGuard.boolean = Boolean
end




do
    type EnumTypeChecker = TypeChecker<EnumTypeChecker> & {
        IsA: SelfReturn<EnumTypeChecker, Enum | EnumItem | (any?) -> Enum | EnumItem>;
        isA: SelfReturn<EnumTypeChecker, Enum | EnumItem | (any?) -> Enum | EnumItem>;
    };

    local EnumChecker: TypeCheckerConstructor<EnumTypeChecker>, EnumCheckerClass = TypeGuard.Template("Enum")

    function EnumCheckerClass:_Initial(Value)
        local GotType = typeof(Value)

        if (GotType ~= TYPE_ENUM_ITEM and GotType ~= TYPE_ENUM) then
            return false, "Expected EnumItem or Enum, got " .. GotType
        end

        return true, EMPTY_STRING
    end

    --- Ensures that a passed EnumItem is either equivalent to an EnumItem or a sub-item of an Enum class
    function EnumCheckerClass:IsA(TargetEnum)
        ExpectType(TargetEnum, EXPECT_ENUM_OR_ENUM_ITEM_OR_FUNCTION, 1)

        return self:_AddConstraint("IsA", function(_, Value, TargetEnum)
            local TargetType = typeof(TargetEnum)

            -- Both are EnumItems
            if (TargetType == TYPE_ENUM_ITEM) then
                if (Value == TargetEnum) then
                    return true, EMPTY_STRING
                end

                return false, "Expected " .. tostring(TargetEnum) .. ", got " .. tostring(Value)
            end

            -- TargetType is an Enum
            if (table.find(TargetEnum:GetEnumItems(), Value) == nil) then
                return false, "Expected a " .. tostring(TargetEnum) .. ", got " .. tostring(Value)
            end

            return true, EMPTY_STRING
        end, TargetEnum)
    end
    EnumCheckerClass.isA = EnumCheckerClass.IsA

    EnumCheckerClass._InitialConstraint = EnumCheckerClass.IsA

    TypeGuard.Enum = EnumChecker
end




do
    type ThreadTypeChecker = TypeChecker<ThreadTypeChecker> & {
        IsDead: SelfReturn<ThreadTypeChecker>;
        isDead: SelfReturn<ThreadTypeChecker>;

        IsSuspended: SelfReturn<ThreadTypeChecker>;
        isSuspended: SelfReturn<ThreadTypeChecker>;

        IsRunning: SelfReturn<ThreadTypeChecker>;
        isRunning: SelfReturn<ThreadTypeChecker>;

        IsNormal: SelfReturn<ThreadTypeChecker>;
        isNormal: SelfReturn<ThreadTypeChecker>;

        HasStatus: SelfReturn<ThreadTypeChecker, string | (any?) -> string>;
        hasStatus: SelfReturn<ThreadTypeChecker, string | (any?) -> string>;
    };

    local ThreadChecker: TypeCheckerConstructor<ThreadTypeChecker>, ThreadCheckerClass = TypeGuard.Template("Thread")
    ThreadCheckerClass._Initial = CreateStandardInitial(TYPE_THREAD)

    function ThreadCheckerClass:IsDead()
        return self:HasStatus("dead"):_AddTag("StatusCheck")
    end

    function ThreadCheckerClass:IsSuspended()
        return self:HasStatus("suspended"):_AddTag("StatusCheck")
    end

    function ThreadCheckerClass:IsRunning()
        return self:HasStatus("running"):_AddTag("StatusCheck")
    end

    function ThreadCheckerClass:IsNormal()
        return self:HasStatus("normal"):_AddTag("StatusCheck")
    end

    --- Checks the coroutine's status against a given status string
    function ThreadCheckerClass:HasStatus(Status)
        ExpectType(Status, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("HasStatus", function(_, Thread, Status)
            local CurrentStatus = coroutine.status(Thread)

            if (CurrentStatus == Status) then
                return true, EMPTY_STRING
            end

            return false, "Expected thread to have status '" .. Status .. "', got " .. CurrentStatus
        end, Status)
    end

    TypeGuard._InitialConstraint = ThreadCheckerClass.HasStatus

    TypeGuard.Thread = ThreadChecker
    TypeGuard.thread = ThreadChecker
end



-- Luau data types
TypeGuard.Axes = TypeGuard.FromTypeName("Axes")
TypeGuard.BrickColor = TypeGuard.FromTypeName("BrickColor")
TypeGuard.CatalogSearchParams = TypeGuard.FromTypeName("CatalogSearchParams")
TypeGuard.CFrame = TypeGuard.FromTypeName("CFrame")
TypeGuard.Color3 = TypeGuard.FromTypeName("Color3")
TypeGuard.ColorSequence = TypeGuard.FromTypeName("ColorSequence")
TypeGuard.ColorSequenceKeypoint = TypeGuard.FromTypeName("ColorSequenceKeypoint")
TypeGuard.DateTime = TypeGuard.FromTypeName("DateTime")
TypeGuard.DockWidgetPluginGuiInfo = TypeGuard.FromTypeName("DockWidgetPluginGuiInfo")
TypeGuard.Enums = TypeGuard.FromTypeName("Enums")
TypeGuard.Faces = TypeGuard.FromTypeName("Faces")
TypeGuard.FloatCurveKey = TypeGuard.FromTypeName("FloatCurveKey")
TypeGuard.NumberRange = TypeGuard.FromTypeName("NumberRange")
TypeGuard.NumberSequence = TypeGuard.FromTypeName("NumberSequence")
TypeGuard.NumberSequenceKeypoint = TypeGuard.FromTypeName("NumberSequenceKeypoint")
TypeGuard.OverlapParams = TypeGuard.FromTypeName("OverlapParams")
TypeGuard.PathWaypoint = TypeGuard.FromTypeName("PathWaypoint")
TypeGuard.PhysicalProperties = TypeGuard.FromTypeName("PhysicalProperties")
TypeGuard.Random = TypeGuard.FromTypeName("Random")
TypeGuard.Ray = TypeGuard.FromTypeName("Ray")
TypeGuard.RaycastParams = TypeGuard.FromTypeName("RaycastParams")
TypeGuard.RaycastResult = TypeGuard.FromTypeName("RaycastResult")
TypeGuard.RBXScriptConnection = TypeGuard.FromTypeName("RBXScriptConnection")
TypeGuard.RBXScriptSignal = TypeGuard.FromTypeName("RBXScriptSignal")
TypeGuard.Rect = TypeGuard.FromTypeName("Rect")
TypeGuard.Region3 = TypeGuard.FromTypeName("Region3")
TypeGuard.Region3int16 = TypeGuard.FromTypeName("Region3int16")
TypeGuard.TweenInfo = TypeGuard.FromTypeName("TweenInfo")
TypeGuard.UDim = TypeGuard.FromTypeName("UDim")
TypeGuard.UDim2 = TypeGuard.FromTypeName("UDim2")
TypeGuard.Vector2 = TypeGuard.FromTypeName("Vector2")
TypeGuard.Vector2int16 = TypeGuard.FromTypeName("Vector2int16")
TypeGuard.Vector3 = TypeGuard.FromTypeName("Vector3")
TypeGuard.Vector3int16 = TypeGuard.FromTypeName("Vector3int16")

-- Extra base Lua data types
TypeGuard.Function = TypeGuard.FromTypeName(TYPE_FUNCTION)
TypeGuard[TYPE_FUNCTION] = TypeGuard.Function

TypeGuard.Userdata = TypeGuard.FromTypeName(TYPE_USERDATA)
TypeGuard[TYPE_USERDATA] = TypeGuard.Userdata

TypeGuard.Nil = TypeGuard.FromTypeName(TYPE_NIL)
TypeGuard[TYPE_NIL] = TypeGuard.Nil

--- Creates a function which checks params as if they were a strict Array checker
function TypeGuard.Params(...: TypeChecker<any>)
    local Params = {...}

    for Index, ParamChecker in Params do
        TypeGuard._AssertIsTypeBase(ParamChecker, Index)
    end

    local Checker = TypeGuard.Array():StructuralEquals(Params):DenoteParams()

    return function(...)
        Checker:Assert({...})
    end
end
TypeGuard.params = TypeGuard.Params

--- Creates a function which checks variadic params against a single given TypeChecker
function TypeGuard.VariadicParams(CompareType: TypeChecker<any>)
    TypeGuard._AssertIsTypeBase(CompareType, 1)

    local Checker = TypeGuard.Array():OfType(CompareType):DenoteParams()

    return function(...)
        Checker:Assert({...})
    end
end
TypeGuard.variadicParams = TypeGuard.VariadicParams


--- Creates a function which checks params as if they were a strict Array checker, using context as the first param; context is passed down to functional constraint args
function TypeGuard.ParamsWithContext(...: TypeChecker<any>)
    local Params = {...}

    for Index, ParamChecker in Params do
        TypeGuard._AssertIsTypeBase(ParamChecker, Index)
    end

    local Checker = TypeGuard.Array():StructuralEquals(Params):DenoteParams()

    return function(Context: any?, ...)
        Checker:WithContext(Context):Assert({...})
    end
end

--- Creates a function which checks variadic params against a single given TypeChecker, using context as the first param; context is passed down to functional constraint args
function TypeGuard.VariadicParamsWithContext(CompareType: TypeChecker<any>)
    TypeGuard._AssertIsTypeBase(CompareType, 1)

    local Checker = TypeGuard.Array():OfType(CompareType):DenoteParams()

    return function(Context: any?, ...)
        Checker:WithContext(Context):Assert({...})
    end
end

--- Wraps a function in a param checker function
function TypeGuard.WrapFunctionParams(Call: (...any) -> (...any), ...: TypeChecker<any>)
    ExpectType(Call, EXPECT_FUNCTION, 1)

    for Index = 1, select("#", ...) do
        TypeGuard._AssertIsTypeBase(select(Index, ...), Index)
    end

    local ParamChecker = TypeGuard.Params(...)

    return function(...)
        ParamChecker(...)
        return Call(...)
    end
end

--- Wraps a function in a variadic param checker function
function TypeGuard.WrapFunctionVariadicParams(Call: (...any) -> (...any), VariadicParamType: TypeChecker<any>)
    ExpectType(Call, EXPECT_FUNCTION, 1)
    TypeGuard._AssertIsTypeBase(VariadicParamType, 2)

    local ParamChecker = TypeGuard.VariadicParams(VariadicParamType)

    return function(...)
        ParamChecker(...)
        return Call(...)
    end
end

return TypeGuard]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb84</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TypeGuard.spec</string>
							<string name="ScriptGuid">{71434631-26E8-47FD-946A-2E5E052E5810}</string>
							<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")

return function()
    local TypeGuard = require(script.Parent)

    describe("Template", function()
        it("should reject no Name given", function()
            expect(function()
                TypeGuard.Template()
            end).to.throw()
        end)

        it("should reject incorrect types for Name", function()
            expect(function()
                TypeGuard.Template(1)
            end).to.throw()

            expect(function()
                TypeGuard.Template({})
            end).to.throw()

            expect(function()
                TypeGuard.Template(true)
            end).to.throw()

            expect(function()
                TypeGuard.Template("Test")
            end).never.to.throw()
        end)

        it("should return a constructor function and a TypeChecker class for extension", function()
            local TestCreate, TestClass = TypeGuard.Template("Test")
            expect(TestCreate).to.be.a("function")
            expect(TestClass).to.be.a("table")
            expect(TestClass.IsTemplate).to.equal(true)
        end)
    end)

    describe("Params", function()
        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.Params(1)
            end).to.throw()

            expect(function()
                TypeGuard.Params({})
            end).to.throw()

            expect(function()
                TypeGuard.Params(true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.Params(TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.Params(TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.Params(TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should check one type", function()
            expect(function()
                TypeGuard.Params(TypeGuard.Number())(1)
            end).never.to.throw()

            expect(function()
                TypeGuard.Params(TypeGuard.Number())("Test")
            end).to.throw()
        end)

        it("should check multiple types", function()
            expect(function()
                TypeGuard.Params(TypeGuard.Number(), TypeGuard.String())(1, "Test")
            end).never.to.throw()

            expect(function()
                TypeGuard.Params(TypeGuard.Number(), TypeGuard.String())(1, 1)
            end).to.throw()
        end)
    end)

    describe("ParamsWithContext", function()
        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.ParamsWithContext(1)
            end).to.throw()

            expect(function()
                TypeGuard.ParamsWithContext({})
            end).to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should check one type", function()
            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number())(nil, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number())(nil, "Test")
            end).to.throw()
        end)

        it("should accept a context as first arg (or nil)", function()
            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number())("Test", 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number())(nil, 1)
            end).never.to.throw()
        end)

        it("should pass the context down", function()
            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number():Equals(function(Context)
                    return Context.MustEqual
                end))({MustEqual = 1}, 1)
            end).never.to.throw()
        end)

        it("should check multiple types", function()
            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number(), TypeGuard.String())(nil, 1, "Test")
            end).never.to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number(), TypeGuard.String())(nil, 1, 1)
            end).to.throw()
        end)
    end)

    describe("VariadicParams", function()
        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.VariadicParams(1)
            end).to.throw()

            expect(function()
                TypeGuard.VariadicParams({})
            end).to.throw()

            expect(function()
                TypeGuard.VariadicParams(true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParams(TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should check one type", function()
            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Number())(1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Number())("Test")
            end).to.throw()
        end)

        it("should check multiple types", function()
            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Number())(1, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Number())(1, "Test")
            end).to.throw()
        end)
    end)

    describe("VariadicParamsWithContext", function()
        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(1)
            end).to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext({})
            end).to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should check one type", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())(nil, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())(nil, "Test")
            end).to.throw()
        end)

        it("should accept a context as first arg (or nil)", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())("Test", 1, 1, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())(nil, 1, 1, 1)
            end).never.to.throw()
        end)

        it("should pass the context down", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number():Equals(function(Context)
                    return Context.MustEqual
                end))({MustEqual = 1}, 1, 1, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number():Equals(function(Context)
                    return Context.MustEqual
                end))({MustEqual = 1}, 1, 1, 2)
            end).to.throw()
        end)

        it("should check multiple types", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())(nil, 1, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())(nil, 1, "Test")
            end).to.throw()
        end)
    end)

    describe("WrapFunctionParams", function()
        it("should reject non functions as first arg", function()
            expect(function()
                TypeGuard.WrapFunctionParams(1)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams({})
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(true)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(function() end)
            end).never.to.throw()
        end)

        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.WrapFunctionParams(function() end, 1)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(function() end, {})
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(function() end, true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.WrapFunctionParams(function() end, TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(function() end, TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(function() end, TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should wrap a function", function()
            local function TestFunction(_X, _Y, _Z) end

            local TestWrapped = TypeGuard.WrapFunctionParams(TestFunction, TypeGuard.Number(), TypeGuard.String(), TypeGuard.Boolean())
            expect(TestWrapped).to.be.a("function")

            expect(function()
                TestWrapped(1, "x", true)
            end).never.to.throw()

            expect(function()
                TestWrapped(1, "x", "y")
            end).to.throw()

            expect(function()
                TestWrapped(1, "x", true, "y")
            end).to.throw()

            expect(function()
                TestWrapped("1", "x", true)
            end).to.throw()
        end)
    end)

    describe("WrapFunctionVariadicParams", function()
        it("should reject non functions as first arg", function()
            expect(function()
                TypeGuard.WrapFunctionVariadicParams(1)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams({})
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(true)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, TypeGuard.Number())
            end).never.to.throw()
        end)

        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, 1)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, {})
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should wrap a function", function()
            local function TestFunction(_X, ...) end

            local TestWrapped = TypeGuard.WrapFunctionVariadicParams(TestFunction, TypeGuard.Number())
            expect(TestWrapped).to.be.a("function")

            expect(function()
                TestWrapped(1)
            end).never.to.throw()

            expect(function()
                TestWrapped(1, "x")
            end).to.throw()

            expect(function()
                TestWrapped(1, "x", true)
            end).to.throw()

            expect(function()
                TestWrapped(9, 8, 7, 6, 5, 4, 3, 2, 1)
            end).never.to.throw()
        end)
    end)

    -- These behaviors extend to all TypeChecker implementations
    describe("TypeChecker", function()
        describe("Optional", function()
            it("should accept nil as a checked value", function()
                expect(TypeGuard.Number():Optional():Check(nil)).to.equal(true)
            end)

            it("should accept the target constraint as a checked value if not nil", function()
                expect(TypeGuard.Number():Optional():Check(1)).to.equal(true)
                expect(TypeGuard.Number():Optional():Check("Test")).to.equal(false)
            end)
        end)

        describe("Alias", function()
            it("should reject non-string args", function()
                expect(function()
                    TypeGuard.Number():Alias(1)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():Alias({})
                end).to.throw()

                expect(function()
                    TypeGuard.Number():Alias(true)
                end).to.throw()
            end)

            it("should accept string args", function()
                expect(function()
                    TypeGuard.Number():Alias("Test")
                end).never.to.throw()
            end)

            it("should give a fail string with the alias", function()
                local _, Result = TypeGuard.Number():Or(TypeGuard.Array()):Alias("TestAlias"):Check("Test")
                expect(Result).to.be.a("string")
                expect(Result:match("TestAlias")).to.be.ok()
            end)
        end)

        describe("Or", function()
            it("should reject non-TypeChecker args", function()
                expect(function()
                    TypeGuard.Number():Or(1)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():Or({})
                end).to.throw()

                expect(function()
                    TypeGuard.Number():Or(true)
                end).to.throw()
            end)

            it("should accept TypeChecker args", function()
                expect(function()
                    TypeGuard.Number():Or(TypeGuard.Number())
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():Or(TypeGuard.String())
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():Or(TypeGuard.Array())
                end).never.to.throw()
            end)

            it("should accept function args", function()
                expect(function()
                    TypeGuard.Number():Or(function() end)
                end).never.to.throw()
            end)

            it("should accept inputs if they satisfy a TypeChecker in the or chain", function()
                local Check = TypeGuard.Number():Or(TypeGuard.Boolean())
                expect(Check:Check(1)).to.equal(true)
                expect(Check:Check(true)).to.equal(true)
                expect(Check:Check(false)).to.equal(true)
            end)

            it("should reject inputs if they do not satisfy a TypeChecker in the or chain", function()
                local Check = TypeGuard.Number():Or(TypeGuard.Boolean())
                expect(Check:Check("Test")).to.equal(false)
                expect(Check:Check({})).to.equal(false)
            end)

            it("should accept functional inputs if they return a TypeChecker which satisfies the or chain", function()
                local Check = TypeGuard.Number():Or(function() return TypeGuard.Boolean() end)
                expect(Check:Check(1)).to.equal(true)
                expect(Check:Check(true)).to.equal(true)
                expect(Check:Check(false)).to.equal(true)
            end)

            it("should reject functional inputs if they return a TypeChecker which does not satisfy the or chain", function()
                local Check = TypeGuard.Number():Or(function() return TypeGuard.Boolean() end)
                expect(Check:Check("Test")).to.equal(false)
                expect(Check:Check({})).to.equal(false)
            end)
        end)

        describe("And", function()
            it("should reject non-TypeChecker args", function()
                expect(function()
                    TypeGuard.Number():And(1)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():And({})
                end).to.throw()

                expect(function()
                    TypeGuard.Number():And(true)
                end).to.throw()
            end)

            it("should accept TypeChecker args", function()
                expect(function()
                    TypeGuard.Number():And(TypeGuard.Number())
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():And(TypeGuard.String())
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():And(TypeGuard.Array())
                end).never.to.throw()
            end)

            it("should reject inputs if they do not satisfy at least one TypeChecker in the and chain", function()
                local Check = TypeGuard.Number():And(TypeGuard.Boolean())
                expect(Check:Check(1)).to.equal(false)
                expect(Check:Check(true)).to.equal(false)
                expect(Check:Check(false)).to.equal(false)
            end)

            it("should accept inputs if they satisfy all TypeCheckers in the and chain and reject if they do not (for objects)", function()
                local Check = TypeGuard.Object():OfStructure({X = TypeGuard.Number()})
                                :And(TypeGuard.Object():OfStructure({Y = TypeGuard.String()}))
                                :And(TypeGuard.Object():OfStructure({Z = TypeGuard.Boolean()}))

                expect(Check:Check({X = 1, Y = "A", Z = false})).to.equal(true)
                expect(Check:Check({X = 1})).to.equal(false)
                expect(Check:Check({X = 1, Y = "A", Z = {}})).to.equal(false)
            end)

            it("should accept inputs if they satisfy all TypeCheckers in the and chain and reject if they do not (for Instances)", function()
                local Check = TypeGuard.Instance():OfStructure({Name = TypeGuard.String()})
                              :And(TypeGuard.Instance():OfStructure({
                                  SomeChild = TypeGuard.Instance();
                              }))

                local TestInstance = Instance.new("Folder")
                    local SomeChild = Instance.new("Folder")
                    SomeChild.Name = "SomeChild"
                    SomeChild.Parent = TestInstance

                local TestInstance2 = Instance.new("Folder")
                    local SomeChild2 = Instance.new("Folder")
                    SomeChild2.Name = "SomeChild2"
                    SomeChild2.Parent = TestInstance2

                expect(Check:Check(TestInstance)).to.equal(true)
                expect(Check:Check(TestInstance2)).to.equal(false)
            end)
        end)

        describe("Check", function()
            it("should return a true boolean and an empty string on success", function()
                local Check = TypeGuard.Number()
                local Result, Error = Check:Check(1)
                expect(Result).to.be.a("boolean")
                expect(Result).to.equal(true)
                expect(Error).to.be.a("string")
                expect(Error).to.equal("")
            end)

            it("should return a false boolean and a fail string on failure", function()
                local Check = TypeGuard.Number()
                local Result, Error = Check:Check("Test")
                expect(Result).to.be.a("boolean")
                expect(Result).to.equal(false)
                expect(Error).to.be.a("string")
                expect(Error).never.to.equal("")
            end)
        end)

        describe("Cached", function()
            it("should cache results if Cached is used on simple types", function()
                local Check = TypeGuard.Number():Cached()
                expect(Check:Check(1)).to.equal(true)
                expect(Check:Check(1)).to.equal(true)
            end)

            it("should cache results if Cached is used on complex types", function()
                local Check = TypeGuard.Object():StructuralEquals({X = TypeGuard.Number()}):Cached()
                local Test = {X = 1}
                expect(Check:Check(Test)).to.equal(true)
                Test.Y = 2
                expect(Check:Check(Test)).to.equal(true) -- Technically incorrect but that's the cost of caching: performance increase for temporal correctness
                expect(Check:Check({X = 1})).to.equal(true)
            end)
        end)

        describe("WrapCheck", function()
            it("should return a function", function()
                expect(TypeGuard.Number():WrapCheck()).to.be.a("function")
            end)

            it("should call Check directly and pass a boolean & status string", function()
                local Check = TypeGuard.Number():WrapCheck()
                local Result, Error = Check(1)
                expect(Result).to.be.a("boolean")
                expect(Result).to.equal(true)
                expect(Error).to.be.a("string")
                expect(Error).to.equal("")

                local Result2, Error2 = Check("Test")
                expect(Result2).to.be.a("boolean")
                expect(Result2).to.equal(false)
                expect(Error2).to.be.a("string")
                expect(Error2).never.to.equal("")
            end)
        end)

        describe("Assert", function()
            it("should not throw when the type is satisfied", function()
                expect(function()
                    TypeGuard.Number():Assert(1)
                end).never.to.throw()
            end)

            it("should throw when the type is unsatisfied, giving the status string", function()
                local Input = "Test"
                local _, CheckResult = TypeGuard.Number():Check(Input)

                expect(function()
                    TypeGuard.Number():Assert(Input)
                end).to.throw(CheckResult)
            end)
        end)

        describe("WrapAssert", function()
            it("should return a function", function()
                expect(TypeGuard.Number():WrapAssert()).to.be.a("function")
            end)

            it("should call Assert directly and pass a boolean & status string", function()
                local Input = 1

                local _, CheckResult = TypeGuard.Number():Check(Input)
                local AssertFunction = TypeGuard.Number():WrapAssert()

                expect(function()
                    AssertFunction(Input)
                end).never.to.throw()

                expect(function()
                    AssertFunction("Test")
                end).to.throw(CheckResult)
            end)
        end)

        describe("Negate", function()
            it("should throw an exception if there are no constraints", function()
                expect(function()
                    TypeGuard.Number():Negate()
                end).to.throw()
            end)

            it("should invert the result of the TypeChecker", function()
                local Check = TypeGuard.Number():Equals(5):Negate()
                expect(Check:Check(1)).to.equal(true)
                expect(Check:Check(5)).to.equal(false)
                expect(Check:Check(10)).to.equal(true)
            end)

            it("should invert only the last constraint", function()
                local Check = TypeGuard.Number():GreaterThan(1):Equals(10):Negate()
                expect(Check:Check(2)).to.equal(true)
                expect(Check:Check(10)).to.equal(false)
                expect(Check:Check(20)).to.equal(true)
            end)
        end)

        describe("WithContext", function()
            it("should accept any value", function()
                expect(function()
                    TypeGuard.Number():WithContext("Test")
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext(1)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext(true)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext(false)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext(nil)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext(Instance.new("Folder"))
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext({X = 1, Y = 2})
                end).never.to.throw()
            end)

            it("should pass the context to constraints", function()
                local DidRun = false
                local Check = TypeGuard.Number():WithContext("Test"):Equals(function(Context)
                    DidRun = true
                    expect(Context).to.equal("Test")
                    return 1
                end)

                expect(Check:Check(1)).to.equal(true)
                expect(DidRun).to.equal(true)
            end)

            it("should pass the root context down even if a new context is given mid-way", function()
                local DidRun = false
                local Check = TypeGuard.Object():WithContext("Test0"):OfStructure({
                    X = TypeGuard.Object():WithContext("Test1"):OfStructure({
                        Y = TypeGuard.Number():WithContext("Test2"):Equals(function(Context)
                            DidRun = true
                            expect(Context).to.equal("Test0")
                            return 1
                        end)
                    });
                })

                expect(Check:Check({
                    X = {
                        Y = 1;
                    }
                })).to.equal(true)
                expect(DidRun).to.equal(true)
            end)
        end)

        describe("FailMessage", function()
            it("should reject non-string args", function()
                expect(function()
                    TypeGuard.Number():FailMessage(1)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():FailMessage(true)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():FailMessage(false)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():FailMessage(nil)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():FailMessage({})
                end).to.throw()
            end)

            it("should accept string args", function()
                expect(function()
                    TypeGuard.Number():FailMessage("Test")
                end).never.to.throw()
            end)

            it("should enforce a custom fail message on failure", function()
                local Check = TypeGuard.Number():FailMessage("0123456789")
                local _, Error = Check:Check("Test")
                expect(Error).to.equal("0123456789")
            end)

            it("should work with Or calls", function()
                local Check = TypeGuard.Number():Or(TypeGuard.Array()):FailMessage("0123456789")
                local _, Error = Check:Check("Test")
                expect(Error).to.equal("0123456789")
            end)

            it("should work with And calls", function()
                local Check = TypeGuard.Number():And(TypeGuard.Array()):FailMessage("0123456789")
                local _, Error = Check:Check("Test")
                expect(Error).to.equal("0123456789")
            end)

            it("should work with Cached calls", function()
                local Check = TypeGuard.Number():Cached():FailMessage("0123456789")

                local _, Error = Check:Check("Test")
                expect(Error).to.equal("0123456789")

                local _, Again = Check:Check("Test")
                expect(Again).to.equal("0123456789")
            end)

            it("should still exist with subsequent constraint calls", function()
                local Check = TypeGuard.Number():FailMessage("0123456789"):RangeInclusive(0, 10):Decimal()
                local _, Error = Check:Check(1000)
                expect(Error).to.equal("0123456789")
            end)
        end)
    end)

    describe("Number", function()
        local Base = TypeGuard.Number()

        describe("Init", function()
            it("should reject non-numbers", function()
                expect(Base:Check("Test")).to.equal(false)
                expect(Base:Check(true)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check(nil)).to.equal(false)
                expect(Base:Check({})).to.equal(false)
            end)

            it("should accept numbers", function()
                expect(Base:Check(1)).to.equal(true)
                expect(Base:Check(1.1)).to.equal(true)
                expect(Base:Check(0)).to.equal(true)
                expect(Base:Check(-1)).to.equal(true)
                expect(Base:Check(-1.1)).to.equal(true)
            end)
        end)

        describe("Integer", function()
            it("should reject non-integers", function()
                expect(Base:Integer():Check(1.1)).to.equal(false)
            end)

            it("should accept integers", function()
                expect(Base:Integer():Check(1)).to.equal(true)
            end)

            it("should accept negative integers", function()
                expect(Base:Integer():Check(-1)).to.equal(true)
            end)

            it("should reject non-numbers", function()
                expect(Base:Integer():Check("Test")).to.equal(false)
            end)
        end)

        describe("Decimal", function()
            it("should reject non-decimals", function()
                expect(Base:Decimal():Check(1)).to.equal(false)
            end)

            it("should accept decimals", function()
                expect(Base:Decimal():Check(1.1)).to.equal(true)
            end)

            it("should accept negative decimals", function()
                expect(Base:Decimal():Check(-1.1)).to.equal(true)
            end)

            it("should reject non-numbers", function()
                expect(Base:Decimal():Check("Test")).to.equal(false)
            end)
        end)

        describe("RangeInclusive", function()
            it("should reject non-numbers", function()
                expect(Base:RangeInclusive(1, 2):Check("Test")).to.equal(false)
            end)

            it("should reject numbers outside of range", function()
                local Range = Base:RangeInclusive(1, 2)
                expect(Range:Check(0)).to.equal(false)
                expect(Range:Check(3)).to.equal(false)

                local FuncRange = Base:RangeInclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(0)).to.equal(false)
                expect(FuncRange:Check(3)).to.equal(false)
            end)

            it("should accept numbers inside of range", function()
                local Range = Base:RangeInclusive(1, 2)
                expect(Range:Check(1)).to.equal(true)
                expect(Range:Check(2)).to.equal(true)

                local FuncRange = Base:RangeInclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(2)).to.equal(true)
            end)

            it("should accept numbers equal to the range bounds", function()
                expect(Base:RangeInclusive(1, 2):Check(1)).to.equal(true)
                expect(Base:RangeInclusive(1, 2):Check(2)).to.equal(true)

                local FuncRange = Base:RangeInclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(1)).to.equal(true)
                expect(FuncRange:Check(2)).to.equal(true)
            end)
        end)

        describe("RangeExclusive", function()
            it("should reject non-numbers", function()
                expect(Base:RangeExclusive(1, 2):Check("Test")).to.equal(false)
            end)

            it("should reject numbers outside of range", function()
                expect(Base:RangeExclusive(1, 2):Check(0)).to.equal(false)
                expect(Base:RangeExclusive(1, 2):Check(3)).to.equal(false)

                local FuncRange = Base:RangeExclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(0)).to.equal(false)
                expect(FuncRange:Check(3)).to.equal(false)
            end)

            it("should accept numbers inside of range", function()
                expect(Base:RangeExclusive(1, 2):Check(1.1)).to.equal(true)
                expect(Base:RangeExclusive(1, 2):Check(1.9)).to.equal(true)

                local FuncRange = Base:RangeExclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(1.1)).to.equal(true)
                expect(FuncRange:Check(1.9)).to.equal(true)
            end)

            it("should reject numbers equal to the range bounds", function()
                expect(Base:RangeExclusive(1, 2):Check(1)).to.equal(false)
                expect(Base:RangeExclusive(1, 2):Check(2)).to.equal(false)

                local FuncRange = Base:RangeExclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(1)).to.equal(false)
                expect(FuncRange:Check(2)).to.equal(false)
            end)
        end)

        describe("Positive", function()
            it("should reject non-numbers", function()
                expect(Base:Positive():Check("Test")).to.equal(false)
            end)

            it("should reject negative numbers", function()
                expect(Base:Positive():Check(-1)).to.equal(false)
            end)

            it("should accept positive numbers", function()
                expect(Base:Positive():Check(0)).to.equal(true)
                expect(Base:Positive():Check(1)).to.equal(true)
            end)
        end)

        describe("Negative", function()
            it("should reject non-numbers", function()
                expect(Base:Negative():Check("Test")).to.equal(false)
            end)

            it("should reject positive numbers", function()
                expect(Base:Negative():Check(0)).to.equal(false)
                expect(Base:Negative():Check(1)).to.equal(false)
            end)

            it("should accept negative numbers", function()
                expect(Base:Negative():Check(-1)).to.equal(true)
            end)
        end)

        describe("Equals", function()
            it("should reject non equal inputs", function()
                expect(Base:Equals(1):Check(2)).to.equal(false)
                expect(Base:Equals(function()
                    return 1
                end):Check(2)).to.equal(false)
            end)

            it("should accept equal inputs", function()
                expect(Base:Equals(1):Check(1)).to.equal(true)
                expect(Base:Equals(function()
                    return 1
                end):Check(1)).to.equal(true)
            end)
        end)

        describe("GreaterThan", function()
            it("should reject numbers less than the first arg", function()
                expect(Base:GreaterThan(1):Check(0)).to.equal(false)
                expect(Base:GreaterThan(function()
                    return 1
                end):Check(1)).to.equal(false)
            end)

            it("should accept numbers greater than the first arg", function()
                expect(Base:GreaterThan(1):Check(2)).to.equal(true)
                expect(Base:GreaterThan(function()
                    return 1
                end):Check(2)).to.equal(true)
            end)
        end)

        describe("IsAKeyIn", function()
            it("should reject a non table as first arg", function()
                expect(function()
                    Base:IsAKeyIn(1)
                end).to.throw()

                expect(function()
                    Base:IsAKeyIn("Test")
                end).to.throw()

                expect(function()
                    Base:IsAKeyIn(true)
                end).to.throw()
            end)

            it("should accept a table or function as first arg", function()
                expect(function()
                    Base:IsAKeyIn({})
                end).never.to.throw()

                expect(function()
                    Base:IsAKeyIn(function() end)
                end).never.to.throw()
            end)

            it("should reject when the value does not exist as a key", function()
                expect(Base:IsAKeyIn({}):Check(123)).to.equal(false)
                expect(Base:IsAKeyIn(function()
                    return {}
                end):Check(123)).to.equal(false)
            end)

            it("should accept when the value does exist as a key", function()
                expect(Base:IsAKeyIn({[123] = true}):Check(123)).to.equal(true)
                expect(Base:IsAKeyIn(function()
                    return {[123] = true}
                end):Check(123)).to.equal(true)
            end)
        end)

        describe("IsAValueIn", function()
            it("should reject a non table as first arg", function()
                expect(function()
                    Base:IsAValueIn(1)
                end).to.throw()

                expect(function()
                    Base:IsAValueIn("Test")
                end).to.throw()

                expect(function()
                    Base:IsAValueIn(true)
                end).to.throw()
            end)

            it("should accept a table or function as first arg", function()
                expect(function()
                    Base:IsAValueIn({})
                end).never.to.throw()

                expect(function()
                    Base:IsAValueIn(function() end)
                end).never.to.throw()
            end)

            it("should reject when the value does not exist in an array", function()
                expect(Base:IsAValueIn({}):Check(123)).to.equal(false)
                expect(Base:IsAValueIn(function()
                    return {}
                end):Check(123)).to.equal(false)
            end)

            it("should accept when the value exists in an array", function()
                expect(Base:IsAValueIn({123}):Check(123)).to.equal(true)
                expect(Base:IsAValueIn(function()
                    return {123}
                end):Check(123)).to.equal(true)
            end)
        end)

        describe("IsNaN", function()
            it("should reject normal numbers", function()
                expect(Base:IsNaN():Check(1)).to.equal(false)
            end)

            it("should accept NaN", function()
                expect(Base:IsNaN():Check(math.sqrt(-1))).to.equal(true)
            end)
        end)

        describe("IsInfinite", function()
            it("should reject finite numbers", function()
                expect(Base:IsInfinite():Check(1)).to.equal(false)
            end)

            it("should accept infinite numbers", function()
                expect(Base:IsInfinite():Check(math.huge)).to.equal(true)
                expect(Base:IsInfinite():Check(-math.huge)).to.equal(true)
            end)
        end)

        describe("IsClose", function()
            it("should reject non-numbers", function()
                expect(Base:IsClose(1):Check("Test")).to.equal(false)
            end)

            it("should reject numbers that are not close", function()
                expect(Base:IsClose(1):Check(2)).to.equal(false)
                expect(Base:IsClose(function()
                    return 1
                end):Check(2)).to.equal(false)
            end)

            it("should accept numbers in the default tolerance (0.00001)", function()
                expect(Base:IsClose(1):Check(1 + 0.000001)).to.equal(true)
                expect(Base:IsClose(function()
                    return 1
                end):Check(1 + 0.000001)).to.equal(true)
            end)

            it("should accept a custom tolerance", function()
                expect(Base:IsClose(1, 0.5):Check(1 + 0.4)).to.equal(true)
                expect(Base:IsClose(function()
                    return 1
                end, 0.5):Check(1 + 0.4)).to.equal(true)
            end)
        end)
    end)

    describe("Boolean", function()
        local Base = TypeGuard.Boolean()

        describe("Init", function()
            it("should reject non-booleans", function()
                expect(Base:Check("Test")).to.equal(false)
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check(nil)).to.equal(false)
                expect(Base:Check({})).to.equal(false)
            end)

            it("should accept booleans", function()
                expect(Base:Check(true)).to.equal(true)
                expect(Base:Check(false)).to.equal(true)
            end)
        end)
    end)

    describe("Instance", function()
        local Base = TypeGuard.Instance()

        describe("Init", function()
            it("should reject non-Instances", function()
                expect(Base:Check("Test")).to.equal(false)
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check(nil)).to.equal(false)
                expect(Base:Check({})).to.equal(false)
            end)

            it("should accept Instances", function()
                expect(Base:Check(Instance.new("Model"))).to.equal(true)
            end)

            it("should use the IsA constraint as the initial constraint", function()
                local Test = TypeGuard.Instance("Model")

                expect(Test:Check(Instance.new("Model"))).to.equal(true)
                expect(Test:Check(Instance.new("Part"))).to.equal(false)
            end)

            it("should use the IsA constraint + the OfStructure constraint if two values are passed", function()
                local Test = TypeGuard.Instance("Model", {
                    Name = TypeGuard.String():Equals("TestName");
                })

                expect(Test:Check(Instance.new("Model"))).to.equal(false)

                local Sample = Instance.new("Model")
                Sample.Name = "TestName"

                expect(Test:Check(Sample)).to.equal(true)
            end)
        end)

        describe("IsA", function()
            it("should reject non-Instances", function()
                expect(Base:IsA("Folder"):Check("Folder")).to.equal(false)
                expect(Base:IsA("Folder"):Check(1)).to.equal(false)
                expect(Base:IsA("Folder"):Check(function() end)).to.equal(false)
                expect(Base:IsA("Folder"):Check(nil)).to.equal(false)
                expect(Base:IsA("Folder"):Check({})).to.equal(false)
            end)

            it("should accept Instances of the specified type string (or function returning type string)", function()
                expect(Base:IsA("Folder"):Check(Instance.new("Folder"))).to.equal(true)
                expect(Base:IsA(function()
                    return "Folder"
                end):Check(Instance.new("Folder"))).to.equal(true)
            end)

            it("should reject Instances of other classes", function()
                expect(Base:IsA("Folder"):Check(Instance.new("Part"))).to.equal(false)
                expect(Base:IsA(function()
                    return "Folder"
                end):Check(Instance.new("Part"))).to.equal(false)
            end)
        end)

        describe("OfStructure", function()
            it("should reject non-Instances", function()
                expect(function()
                    Base:OfStructure({Test = "Test"})
                end).to.throw()

                expect(function()
                    Base:OfStructure({Test = 1})
                end).to.throw()

                expect(function()
                    Base:OfStructure({Test = function() end})
                end).to.throw()
            end)

            it("should accept a map of children and/or properties", function()
                expect(function()
                    Base:OfStructure({
                        Test = TypeGuard.Instance("Folder");
                        Name = TypeGuard.String();
                    })
                end).to.never.throw()
            end)

            it("should reject Instances that do not match the structure", function()
                expect(
                    Base:OfStructure({
                        Test = TypeGuard.Instance("Folder");
                        Name = TypeGuard.String();
                    }):Check(Instance.new("Folder"))
                ).to.equal(false)
            end)

            it("should accept Instances that match the structure", function()
                local SampleTree = Instance.new("Folder")
                    local Test = Instance.new("Folder", SampleTree)
                    Test.Name = "Test"

                expect(
                    Base:OfStructure({
                        Test = TypeGuard.Instance("Folder");
                        Name = TypeGuard.String();
                    }):Check(SampleTree)
                ).to.equal(true)
            end)

            it("should reject Instances that do not match the structure recursively", function()
                local SampleTree = Instance.new("Folder")
                    local Test = Instance.new("Folder", SampleTree)
                    Test.Name = "Test"
                        local Test2 = Instance.new("Part", Test)
                        Test2.Name = "Test2"

                expect(
                    Base:OfStructure({
                        Test = TypeGuard.Instance("Folder"):OfStructure({
                            Test2 = TypeGuard.Instance():OfStructure({
                                Name = TypeGuard.String():Equals("Incorrect Name");
                            });
                            Name = TypeGuard.String():Equals("Test");
                        });
                        Name = TypeGuard.String():Equals("Folder");
                    }):Check(Test)
                ).to.equal(false)
            end)

            it("should accept Instances that match the structure recursively", function()
                local SampleTree = Instance.new("Folder")
                    local Test = Instance.new("Folder", SampleTree)
                    Test.Name = "Test"
                        local Test2 = Instance.new("Part", Test)
                        Test2.Name = "Test2"

                expect(
                    Base:OfStructure({
                        Test = TypeGuard.Instance("Folder"):OfStructure({
                            Test2 = TypeGuard.Instance():OfStructure({
                                Name = TypeGuard.String():Equals("Test2");
                            });
                            Name = TypeGuard.String():Equals("Test");
                        });
                        Name = TypeGuard.String():Equals("Folder");
                    }):Check(Test)
                ).to.equal(false)
            end)
        end)

        describe("StructuralEquals (Strict + OfStructure)", function()
            it("should reject extra flat children", function()
                local SampleTree = Instance.new("Folder")
                    local Test = Instance.new("Folder", SampleTree)
                    Test.Name = "Test"
                    local Test2 = Instance.new("Folder", SampleTree)
                    Test2.Name = "Test2"

                expect(
                    Base:StructuralEquals({
                        Test = TypeGuard.Instance("Folder");
                    }):Check(SampleTree)
                ).to.equal(false)

                expect(
                    Base:StructuralEquals({
                        Test = TypeGuard.Instance("Folder");
                        Test2 = TypeGuard.Instance("Folder");
                    }):Check(SampleTree)
                ).to.equal(true)
            end)

            it("should reject extra children recursively", function()
                local SampleTree = Instance.new("Folder")
                    local Test = Instance.new("Folder", SampleTree)
                    Test.Name = "Test"
                        local Test2 = Instance.new("Folder", Test)
                        Test2.Name = "Test2"
                        local Test22 = Instance.new("Folder", Test)
                        Test22.Name = "Test22"

                expect(
                    Base:StructuralEquals({
                        Test = TypeGuard.Instance("Folder"):StructuralEquals({
                            Test2 = TypeGuard.Instance("Folder");
                            -- No Test22, should reject
                        });
                    }):Check(SampleTree)
                ).to.equal(false)

                expect(
                    Base:StructuralEquals({
                        Test = TypeGuard.Instance("Folder"):StructuralEquals({
                            Test2 = TypeGuard.Instance("Folder");
                            Test22 = TypeGuard.Instance("Folder");
                        });
                    }):Check(SampleTree)
                ).to.equal(true)
            end)
        end)

        describe("HasTag", function()
            it("should reject non-Instances", function()
                expect(Base:HasTag("Test"):Check("Test")).to.equal(false)
                expect(Base:HasTag("Test"):Check(1)).to.equal(false)
                expect(Base:HasTag("Test"):Check(function() end)).to.equal(false)
                expect(Base:HasTag("Test"):Check(nil)).to.equal(false)
                expect(Base:HasTag("Test"):Check({})).to.equal(false)
            end)

            it("should accept Instances with the specified tag", function()
                local Test = Instance.new("Folder")
                CollectionService:AddTag(Test, "TestTag")
                expect(TypeGuard.Instance():HasTag("TestTag"):Check(Test)).to.equal(true)
                expect(TypeGuard.Instance():HasTag(function()
                    return "TestTag"
                end):Check(Test)).to.equal(true)
            end)

            it("should reject Instances without the specified tag", function()
                local Test = Instance.new("Folder")
                expect(TypeGuard.Instance():HasTag("TestTag"):Check(Test)).to.equal(false)
                expect(TypeGuard.Instance():HasTag(function()
                    return "TestTag"
                end):Check(Test)).to.equal(false)
            end)
        end)

        describe("IsAncestorOf", function()
            it("should reject non-Instances", function()
                expect(Base:IsAncestorOf(Instance.new("Folder")):Check("Test")).to.equal(false)
                expect(Base:IsAncestorOf(Instance.new("Folder")):Check(1)).to.equal(false)
                expect(Base:IsAncestorOf(Instance.new("Folder")):Check(function() end)).to.equal(false)
                expect(Base:IsAncestorOf(Instance.new("Folder")):Check(nil)).to.equal(false)
                expect(Base:IsAncestorOf(Instance.new("Folder")):Check({})).to.equal(false)
            end)

            it("should accept Instances that are ancestors of the specified Instance", function()
                local Test = Instance.new("Folder")
                local Test2 = Instance.new("Folder", Test)
                local Test3 = Instance.new("Folder", Test2)

                expect(TypeGuard.Instance():IsAncestorOf(Test2):Check(Test)).to.equal(true)
                expect(TypeGuard.Instance():IsAncestorOf(Test3):Check(Test)).to.equal(true)

                expect(TypeGuard.Instance():IsAncestorOf(function()
                    return Test2
                end):Check(Test)).to.equal(true)
                expect(TypeGuard.Instance():IsAncestorOf(function()
                    return Test3
                end):Check(Test)).to.equal(true)
            end)
        end)

        describe("IsDescendantOf", function()
            it("should reject non-Instances", function()
                expect(Base:IsDescendantOf(Instance.new("Folder")):Check("Test")).to.equal(false)
                expect(Base:IsDescendantOf(Instance.new("Folder")):Check(1)).to.equal(false)
                expect(Base:IsDescendantOf(Instance.new("Folder")):Check(function() end)).to.equal(false)
                expect(Base:IsDescendantOf(Instance.new("Folder")):Check(nil)).to.equal(false)
                expect(Base:IsDescendantOf(Instance.new("Folder")):Check({})).to.equal(false)
            end)

            it("should accept Instances that are descendants of the specified Instance", function()
                local Test = Instance.new("Folder")
                local Test2 = Instance.new("Folder", Test)
                local Test3 = Instance.new("Folder", Test2)

                expect(TypeGuard.Instance():IsDescendantOf(Test):Check(Test2)).to.equal(true)
                expect(TypeGuard.Instance():IsDescendantOf(Test):Check(Test3)).to.equal(true)

                expect(TypeGuard.Instance():IsDescendantOf(function()
                    return Test
                end):Check(Test2)).to.equal(true)
                expect(TypeGuard.Instance():IsDescendantOf(function()
                    return Test
                end):Check(Test3)).to.equal(true)
            end)
        end)

        describe("HasAttribute", function()
            it("should reject non-strings and non-functions as 1st param", function()
                expect(function()
                    Base:HasAttribute(1)
                end).to.throw()

                expect(function()
                    Base:HasAttribute(true)
                end).to.throw()

                expect(function()
                    Base:HasAttribute(nil)
                end).to.throw()
            end)

            it("should accept a string a 1st param", function()
                expect(function()
                    Base:HasAttribute("Test")
                end).never.to.throw()
            end)

            it("should reject non-Instances on check", function()
                expect(Base:HasAttribute("Test"):Check("Test")).to.equal(false)
                expect(Base:HasAttribute("Test"):Check(1)).to.equal(false)
                expect(Base:HasAttribute("Test"):Check(function() end)).to.equal(false)
                expect(Base:HasAttribute("Test"):Check(nil)).to.equal(false)
                expect(Base:HasAttribute("Test"):Check({})).to.equal(false)
            end)

            it("should accept Instances with the specified attribute", function()
                local Test = Instance.new("Folder")
                Test:SetAttribute("TestAttribute", true)
                expect(TypeGuard.Instance():HasAttribute("TestAttribute"):Check(Test)).to.equal(true)
                expect(TypeGuard.Instance():HasAttribute(function()
                    return "TestAttribute"
                end):Check(Test)).to.equal(true)
            end)

            it("should reject Instances without the specified attribute", function()
                local Test = Instance.new("Folder")
                expect(TypeGuard.Instance():HasAttribute("TestAttribute"):Check(Test)).to.equal(false)
                expect(TypeGuard.Instance():HasAttribute(function()
                    return "TestAttribute"
                end):Check(Test)).to.equal(false)
            end)
        end)

        describe("CheckAttribute", function()
            it("should reject non-strings and non-functions as 1st param", function()
                expect(function()
                    Base:CheckAttribute(1)
                end).to.throw()

                expect(function()
                    Base:CheckAttribute(true)
                end).to.throw()

                expect(function()
                    Base:CheckAttribute(nil)
                end).to.throw()
            end)

            it("should reject non-TypeCheckers as 2nd param", function()
                expect(function()
                    Base:CheckAttribute("Test", 1)
                end).to.throw()

                expect(function()
                    Base:CheckAttribute("Test", true)
                end).to.throw()

                expect(function()
                    Base:CheckAttribute("Test", function() end)
                end).to.throw()

                expect(function()
                    Base:CheckAttribute("Test", nil)
                end).to.throw()
            end)

            it("should accept a string & TypeChecker as params", function()
                expect(function()
                    Base:CheckAttribute("Test", TypeGuard.Number())
                end).never.to.throw()
            end)

            it("should reject non-Instances on check", function()
                expect(Base:CheckAttribute("Test", TypeGuard.String()):Check("Test")).to.equal(false)
                expect(Base:CheckAttribute("Test", TypeGuard.String()):Check(1)).to.equal(false)
                expect(Base:CheckAttribute("Test", TypeGuard.String()):Check(function() end)).to.equal(false)
                expect(Base:CheckAttribute("Test", TypeGuard.String()):Check(nil)).to.equal(false)
                expect(Base:CheckAttribute("Test", TypeGuard.String()):Check({})).to.equal(false)
            end)

            it("should accept Instances with the specified attribute", function()
                local Test = Instance.new("Folder")
                Test:SetAttribute("TestAttribute", 123)
                expect(TypeGuard.Instance():CheckAttribute("TestAttribute", TypeGuard.Number()):Check(Test)).to.equal(true)
                expect(TypeGuard.Instance():CheckAttribute(function()
                    return "TestAttribute"
                end, TypeGuard.Number()):Check(Test)).to.equal(true)
            end)

            it("should reject Instances without the specified attribute", function()
                local Test = Instance.new("Folder")
                expect(TypeGuard.Instance():CheckAttribute("TestAttribute", TypeGuard.Number()):Check(Test)).to.equal(false)
                expect(TypeGuard.Instance():CheckAttribute(function()
                    return "TestAttribute"
                end, TypeGuard.Number()):Check(Test)).to.equal(false)
            end)
        end)
    end)

    describe("String", function()
        local Base = TypeGuard.String()

        describe("Init", function()
            it("should accept a string", function()
                expect(Base:Check("Test")).to.equal(true)
            end)

            it("should reject non-strings", function()
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check(nil)).to.equal(false)
                expect(Base:Check({})).to.equal(false)
            end)
        end)

        describe("MinLength", function()
            it("should reject strings shorter than the specified length", function()
                expect(Base:MinLength(5):Check("Test")).to.equal(false)
                expect(Base:MinLength(function()
                    return 5
                end):Check("Test")).to.equal(false)
            end)

            it("should accept strings longer than the specified length", function()
                expect(Base:MinLength(5):Check("Test123")).to.equal(true)
                expect(Base:MinLength(function()
                    return 5
                end):Check("Test123")).to.equal(true)
            end)

            it("should accept strings equal to the specified length", function()
                expect(Base:MinLength(5):Check("12345")).to.equal(true)
                expect(Base:MinLength(function()
                    return 5
                end):Check("12345")).to.equal(true)
            end)
        end)

        describe("MaxLength", function()
            it("should reject strings longer than the specified length", function()
                expect(Base:MaxLength(5):Check("Test123")).to.equal(false)
                expect(Base:MaxLength(function()
                    return 5
                end):Check("Test123")).to.equal(false)
            end)

            it("should accept strings shorter than the specified length", function()
                expect(Base:MaxLength(5):Check("Test")).to.equal(true)
                expect(Base:MaxLength(function()
                    return 5
                end):Check("Test")).to.equal(true)
            end)

            it("should accept strings equal to the specified length", function()
                expect(Base:MaxLength(5):Check("12345")).to.equal(true)
                expect(Base:MaxLength(function()
                    return 5
                end):Check("12345")).to.equal(true)
            end)
        end)

        describe("Pattern", function()
            it("should accept strings matching the specified pattern", function()
                expect(Base:Pattern("[0-9]+"):Check("34789275")).to.equal(true)
                expect(Base:Pattern(function()
                    return "[0-9]+"
                end):Check("34789275")).to.equal(true)
            end)

            it("should reject strings not matching the specified pattern", function()
                expect(Base:Pattern("[0-9]+"):Check("123h4")).to.equal(false)
                expect(Base:Pattern(function()
                    return "[0-9]+"
                end):Check("123h4")).to.equal(false)
            end)
        end)

        describe("Contains", function()
            it("should accept strings containing the specified substring", function()
                expect(Base:Contains("Test"):Check("------Test123")).to.equal(true)
                expect(Base:Contains(function()
                    return "Test"
                end):Check("------Test123")).to.equal(true)
            end)

            it("should reject strings not containing the specified substring", function()
                expect(Base:Contains("Test"):Check("asdfghjkl")).to.equal(false)
                expect(Base:Contains(function()
                    return "Test"
                end):Check("asdfghjkl")).to.equal(false)
            end)
        end)
    end)

    describe("Array", function()
        local Base = TypeGuard.Array()

        describe("Init", function()
            it("should accept an array", function()
                expect(Base:Check({})).to.equal(true)
                expect(Base:Check({1})).to.equal(true)
                expect(Base:Check({1, 2})).to.equal(true)
            end)

            it("should reject non-arrays", function()
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check(nil)).to.equal(false)
                expect(Base:Check({Test = true})).to.equal(false)
            end)
        end)

        describe("OfLength", function()
            it("should reject arrays shorter than the specified length", function()
                expect(Base:OfLength(5):Check({1, 2, 3, 4})).to.equal(false)
                expect(Base:OfLength(function()
                    return 5
                end):Check({1, 2, 3, 4})).to.equal(false)
            end)

            it("should accept arrays longer than the specified length", function()
                expect(Base:OfLength(5):Check({1, 2, 3, 4, 5})).to.equal(true)
                expect(Base:OfLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5})).to.equal(true)
            end)

            it("should reject arrays greater than the specified length", function()
                expect(Base:OfLength(5):Check({1, 2, 3, 4, 5, 6})).to.equal(false)
                expect(Base:OfLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5, 6})).to.equal(false)
            end)
        end)

        describe("MinLength", function()
            it("should reject arrays shorter than the specified length", function()
                expect(Base:MinLength(5):Check({1, 2, 3, 4})).to.equal(false)
                expect(Base:MinLength(function()
                    return 5
                end):Check({1, 2, 3, 4})).to.equal(false)
            end)

            it("should accept arrays equal to the specified length", function()
                expect(Base:MinLength(5):Check({1, 2, 3, 4, 5})).to.equal(true)
                expect(Base:MinLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5})).to.equal(true)
            end)

            it("should accept arrays longer than the specified length", function()
                expect(Base:MinLength(5):Check({1, 2, 3, 4, 5, 6})).to.equal(true)
                expect(Base:MinLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5, 6})).to.equal(true)
            end)
        end)

        describe("MaxLength", function()
            it("should reject arrays longer than the specified length", function()
                expect(Base:MaxLength(5):Check({1, 2, 3, 4, 5, 6})).to.equal(false)
                expect(Base:MaxLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5, 6})).to.equal(false)
            end)

            it("should accept arrays equal to the specified length", function()
                expect(Base:MaxLength(5):Check({1, 2, 3, 4, 5})).to.equal(true)
                expect(Base:MaxLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5})).to.equal(true)
            end)

            it("should accept arrays shorter than the specified length", function()
                expect(Base:MaxLength(5):Check({1, 2, 3, 4})).to.equal(true)
                expect(Base:MaxLength(function()
                    return 5
                end):Check({1, 2, 3, 4})).to.equal(true)
            end)
        end)

        describe("Contains", function()
            it("should accept arrays containing the specified element", function()
                expect(Base:Contains(1):Check({1, 2, 3, 4})).to.equal(true)
                expect(Base:Contains(function()
                    return 1
                end):Check({1, 2, 3, 4})).to.equal(true)
            end)

            it("should reject arrays not containing the specified element", function()
                expect(Base:Contains(1):Check({2, 3, 4})).to.equal(false)
                expect(Base:Contains(function()
                    return 1
                end):Check({2, 3, 4})).to.equal(false)
            end)
        end)

        describe("OfType", function()
            it("should accept arrays containing only the specified type", function()
                expect(Base:OfType(TypeGuard.Number()):Check({1, 2, 3, 4})).to.equal(true)
            end)

            it("should reject arrays containing elements of other types", function()
                expect(Base:OfType(TypeGuard.Number()):Check({1, "Test", 3, 4})).to.equal(false)
            end)
        end)

        describe("OfStructure", function()
            it("should throw for non TypeCheckers inside the template array", function()
                expect(function()
                    Base:OfStructure({1})
                end).to.throw()

                expect(function()
                    Base:OfStructure({function() end})
                end).to.throw()

                expect(function()
                    Base:OfStructure({{}})
                end).to.throw()
            end)

            it("should not throw for TypeCheckers inside the template array", function()
                expect(function()
                    Base:OfStructure({TypeGuard.Number()})
                end).never.to.throw()

                expect(function()
                    Base:OfStructure({TypeGuard.String()})
                end).never.to.throw()

                expect(function()
                    Base:OfStructure({TypeGuard.Array()})
                end).never.to.throw()
            end)

            it("should accept arrays with additional contents", function()
                expect(Base:OfStructure({TypeGuard.Number(), TypeGuard.Number()}):Check({1, 2, 3})).to.equal(true)
            end)

            it("should accept an array of a correct type (numerical)", function()
                expect(Base:OfStructure({
                    TypeGuard.Number(), TypeGuard.Number(),
                    TypeGuard.Number(), TypeGuard.Number()
                }):Check({1, 2, 3, 4})).to.equal(true)
            end)

            it("should reject an array of a incorrect type (numerical)", function()
                expect(Base:OfStructure({
                    TypeGuard.Number(), TypeGuard.Number(),
                    TypeGuard.Number(), TypeGuard.Number()
                }):Check({1, 2, "Test", 4})).to.equal(false)
            end)

            it("should check recursively", function()
                expect(Base:OfStructure({
                    [1] = Base:OfStructure({TypeGuard.String()});
                    [2] = Base:OfStructure({TypeGuard.Boolean()});
                }):Check({ {"Test"}, {true} })).to.equal(true)
            end)
        end)

        describe("StructuralEquals (Strict + OfStructure)", function()
            it("should reject arrays with additional contents", function()
                local Checker = Base:StructuralEquals({TypeGuard.Number(), TypeGuard.Number()})
                expect(Checker:Check({1, 2})).to.equal(true)
                expect(Checker:Check({1, 2, 3})).to.equal(false)
            end)
        end)

        describe("IsFrozen", function()
            it("should accept frozen arrays", function()
                local Test = {1, 2, 3}
                table.freeze(Test)
                expect(Base:IsFrozen():Check(Test)).to.equal(true)
            end)

            it("should reject non-frozen arrays", function()
                local Test = {1, 2, 3}
                expect(Base:IsFrozen():Check(Test)).to.equal(false)
            end)
        end)

        describe("IsOrdered", function()
            it("should allow nil params", function()
                expect(function()
                    Base:IsOrdered()
                end).never.to.throw()
            end)

            it("should accept params which are booleans only if not nil (for ascending & descending)", function()
                expect(function()
                    Base:IsOrdered(true)
                    Base:IsOrdered(false)
                end).never.to.throw()

                expect(function()
                    Base:IsOrdered(1)
                end).to.throw()

                expect(function()
                    Base:IsOrdered({})
                end).to.throw()
            end)

            it("should accept single-item arrays", function()
                expect(Base:IsOrdered():Check({1})).to.equal(true)
            end)

            it("should check if an array is ordered as descending", function()
                expect(Base:IsOrdered(true):Check({3, 2, 1})).to.equal(true)
                expect(Base:IsOrdered(true):Check({1, 2, 3})).to.equal(false)
                expect(Base:IsOrdered(function()
                    return true
                end):Check({3, 2, 1})).to.equal(true)
                expect(Base:IsOrdered(function()
                    return true
                end):Check({1, 2, 3})).to.equal(false)
            end)

            it("should check if an array is ordered as ascending", function()
                expect(Base:IsOrdered(false):Check({1, 2, 3})).to.equal(true)
                expect(Base:IsOrdered(false):Check({3, 2, 1})).to.equal(false)
                expect(Base:IsOrdered():Check({1, 2, 3})).to.equal(true)
                expect(Base:IsOrdered():Check({3, 2, 1})).to.equal(false)
                expect(Base:IsOrdered(function()
                    return false
                end):Check({1, 2, 3})).to.equal(true)
                expect(Base:IsOrdered(function()
                    return false
                end):Check({3, 2, 1})).to.equal(false)
            end)

            it("should reject non ordered arrays", function()
                expect(Base:IsOrdered(false):Check({1, 2, 4, 3})).to.equal(false)
                expect(Base:IsOrdered(true):Check({1, 2, 4, 3})).to.equal(false)
                expect(Base:IsOrdered(function()
                    return false
                end):Check({1, 2, 4, 3})).to.equal(false)
                expect(Base:IsOrdered(function()
                    return true
                end):Check({1, 2, 4, 3})).to.equal(false)
            end)
        end)
    end)

    describe("Nil", function()
        describe("Init", function()
            it("should accept nil", function()
                expect(TypeGuard.Nil():Check(nil)).to.equal(true)
            end)

            it("should reject non-nil", function()
                expect(TypeGuard.Nil():Check(1)).to.equal(false)
                expect(TypeGuard.Nil():Check(function() end)).to.equal(false)
                expect(TypeGuard.Nil():Check({})).to.equal(false)
                expect(TypeGuard.Nil():Check(false)).to.equal(false)
            end)
        end)
    end)

    describe("Enum", function()
        describe("Init", function()
            it("should throw given non-EnumItem, non-Enum values", function()
                expect(function()
                    TypeGuard.Enum(1)
                end).to.throw()

                expect(function()
                    TypeGuard.Enum(true)
                end).to.throw()

                expect(function()
                    TypeGuard.Enum({})
                end).to.throw()
            end)

            it("should not throw given EnumItem or Enum (or function) values", function()
                expect(function()
                    TypeGuard.Enum(Enum.AccessoryType)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Enum(Enum.AccessoryType.Shirt)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Enum(function()
                        return Enum.AccessoryType.Shirt
                    end)
                end).never.to.throw()
            end)
        end)

        describe("IsA", function()
            it("should accept an Enum item if the respective EnumItem is a sub-item", function()
                expect(TypeGuard.Enum(Enum.AccessoryType):Check(Enum.AccessoryType.Shirt)).to.equal(true)
                expect(TypeGuard.Enum(function()
                    return Enum.AccessoryType
                end):Check(Enum.AccessoryType.Shirt)).to.equal(true)
            end)

            it("should reject EnumItems which are not part of the Enum class", function()
                expect(TypeGuard.Enum(Enum.AccessoryType):Check(Enum.AlphaMode.Overlay)).to.equal(false)
                expect(TypeGuard.Enum(function()
                    return Enum.AccessoryType
                end):Check(Enum.AlphaMode.Overlay)).to.equal(false)
            end)

            it("should accept EnumItems which are equal", function()
                expect(TypeGuard.Enum(Enum.AccessoryType.Face):Check(Enum.AccessoryType.Face)).to.equal(true)
                expect(TypeGuard.Enum(function()
                    return Enum.AccessoryType.Face
                end):Check(Enum.AccessoryType.Face)).to.equal(true)
            end)
        end)
    end)

    describe("Thread", function()
        local Base = TypeGuard.Thread()

        describe("Init", function()
            it("should reject non-thread values", function()
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check({})).to.equal(false)
            end)

            it("should accept thread values", function()
                expect(Base:Check(coroutine.create(function() end))).to.equal(true)
            end)
        end)

        describe("HasStatus", function()
            it("should accept running threads given 'running'", function()
                local Thread = coroutine.running()

                expect(Base:HasStatus("suspended"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("running"):Check(Thread)).to.equal(true)
                expect(Base:HasStatus("normal"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("dead"):Check(Thread)).to.equal(false)

                expect(Base:HasStatus(function() return "suspended" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "running" end):Check(Thread)).to.equal(true)
                expect(Base:HasStatus(function() return "normal" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "dead" end):Check(Thread)).to.equal(false)
            end)

            it("should accept suspended threads given 'suspended'", function()
                local Thread = task.spawn(function()
                    task.wait(1)
                end)

                expect(Base:HasStatus("suspended"):Check(Thread)).to.equal(true)
                expect(Base:HasStatus("running"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("normal"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("dead"):Check(Thread)).to.equal(false)

                expect(Base:HasStatus(function() return "suspended" end):Check(Thread)).to.equal(true)
                expect(Base:HasStatus(function() return "running" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "normal" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "dead" end):Check(Thread)).to.equal(false)
            end)

            it("should accept threads given 'dead'", function()
                local Thread = task.spawn(function() end)

                expect(Base:HasStatus("suspended"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("running"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("normal"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("dead"):Check(Thread)).to.equal(true)

                expect(Base:HasStatus(function() return "suspended" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "running" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "normal" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "dead" end):Check(Thread)).to.equal(true)
            end)

            it("should accept threads given 'normal'", function()
                local DidRun = false
                local TestCoroutine = coroutine.create(function(Callback)
                    Callback()
                end)

                task.spawn(function()
                    local Thread = coroutine.running()

                    task.spawn(TestCoroutine, function()
                        expect(Base:HasStatus("suspended"):Check(Thread)).to.equal(false)
                        expect(Base:HasStatus("running"):Check(Thread)).to.equal(false)
                        expect(Base:HasStatus("normal"):Check(Thread)).to.equal(true)
                        expect(Base:HasStatus("dead"):Check(Thread)).to.equal(false)

                        expect(Base:HasStatus(function() return "suspended" end):Check(Thread)).to.equal(false)
                        expect(Base:HasStatus(function() return "running" end):Check(Thread)).to.equal(false)
                        expect(Base:HasStatus(function() return "normal" end):Check(Thread)).to.equal(true)
                        expect(Base:HasStatus(function() return "dead" end):Check(Thread)).to.equal(false)
                        DidRun = true
                    end)
                end)

                expect(DidRun).to.equal(true)
            end)
        end)
    end)

    describe("Object", function()
        local Base = TypeGuard.Object()

        describe("Init", function()
            it("should reject non-object values", function()
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check({1})).to.equal(false)
            end)

            it("should accept object values", function()
                expect(Base:Check({})).to.equal(true)
                expect(Base:Check({Test = 123})).to.equal(true)
                expect(Base:Check({Test = false})).to.equal(true)
            end)
        end)

        describe("OfValueType", function()
            it("should accept an object with the given value type", function()
                expect(Base:OfValueType(TypeGuard.Number()):Check({Test = 123})).to.equal(true)
                expect(Base:OfValueType(TypeGuard.Number()):Check({Test = 123, Another = 987})).to.equal(true)
            end)

            it("should reject an object with a different value type", function()
                expect(Base:OfValueType(TypeGuard.Number()):Check({Test1 = 123, Test2 = "123"})).to.equal(false)
                expect(Base:OfValueType(TypeGuard.Number()):Check({Test = "123", Another = "987"})).to.equal(false)
            end)
        end)

        describe("OfKeyType", function()
            it("should accept an object with the given key type", function()
                expect(Base:OfKeyType(TypeGuard.String()):Check({Test = 123})).to.equal(true)
                expect(Base:OfKeyType(TypeGuard.String()):Check({Test = 123, Another = 987})).to.equal(true)
            end)

            it("should reject an object with a different key type", function()
                expect(Base:OfKeyType(TypeGuard.String()):Check({[{}] = true})).to.equal(false)
                expect(Base:OfKeyType(TypeGuard.String()):Check({[Instance.new("Part")] = true})).to.equal(false)
            end)
        end)

        describe("OfStructure", function()
            it("should accept an object with the given structure", function()
                expect(Base:OfStructure({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = true})).to.equal(true)
            end)

            it("should reject an object with a different structure", function()
                expect(Base:OfStructure({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = "true"})).to.equal(false)
            end)

            it("should accept additional fields when not in strict mode", function()
                expect(Base:OfStructure({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = true, Test2 = "123"})).to.equal(true)
            end)

            it("should recurse given sub object TypeCheckers", function()
                expect(Base:OfStructure({
                    Test = TypeGuard.Object({
                        Test = TypeGuard.Number(),
                        Another = TypeGuard.Boolean()
                    })
                }):Check({Test = {Test = 123, Another = true}})).to.equal(true)
            end)
        end)

        describe("StructuralEquals (OfStructure + Strict)", function()
            it("should accept an object with the given structure", function()
                expect(Base:StructuralEquals({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = true})).to.equal(true)
            end)

            it("should reject an object with a different structure", function()
                expect(Base:StructuralEquals({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = "true"})).to.equal(false)
            end)

            it("should reject additional fields when not in strict mode", function()
                expect(Base:StructuralEquals({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = true, Test2 = "123"})).to.equal(false)
            end)

            it("should recurse given sub object TypeCheckers but not enforce strict recursively", function()
                expect(Base:StructuralEquals({
                    Test = TypeGuard.Object({
                        Test = TypeGuard.Number(),
                        Another = TypeGuard.Boolean()
                    })
                }):Check({Test = {Test = 123, Another = true, Final = {}}})).to.equal(true)
            end)
        end)

        describe("IsFrozen", function()
            it("should accept frozen objects", function()
                local Test = {X = 1, Y = 2, Z = 3}
                table.freeze(Test)
                expect(Base:IsFrozen():Check(Test)).to.equal(true)
            end)

            it("should reject non-frozen objects", function()
                local Test = {X = 1, Y = 2, Z = 3}
                expect(Base:IsFrozen():Check(Test)).to.equal(false)
            end)
        end)

        describe("CheckMetatable", function()
            it("should reject non-TypeCheckers", function()
                expect(function()
                    Base:CheckMetatable(1)
                end).to.throw()

                expect(function()
                    Base:CheckMetatable(function() end)
                end).to.throw()

                expect(function()
                    Base:CheckMetatable({})
                end).to.throw()

                expect(function()
                    Base:CheckMetatable(Instance.new("Part"))
                end).to.throw()
            end)

            it("should run the provided TypeChecker on the metatable", function()
                local Test = {}
                local MT = {__index = Test}
                setmetatable(Test, MT)

                expect(Base:CheckMetatable(Base:Equals(MT)):Check(Test)).to.equal(true)
                expect(Base:CheckMetatable(TypeGuard.Number()):Check(Test)).to.equal(false)
            end)
        end)
    end)
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb85</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBX89603E10B1E744FCBDD0170C24A4A5D2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">XSignal</string>
				<string name="ScriptGuid">{3D8A5B3E-A411-4A95-AACE-C0E630D1AFB9}</string>
				<ProtectedString name="Source"><![CDATA[local Connection = require(script.Connection)
local TypeGuard = require(script.Parent:WaitForChild("TypeGuard"))

local function BLANK_FUNCTION() end

local CHECK_TYPES = true

local DEFAULT_AWAIT_FIRST_TIMEOUT_SECONDS = 60
local DEFAULT_AWAIT_ALL_TIMEOUT_SECONDS = 60
local DEFAULT_WAIT_TIMEOUT_SECONDS = 60

local ERR_CONNECTION_ALREADY_CREATED = "Connection already created in slot %d"
local ERR_WAIT_TIMEOUT = "Wait call timed out (time elapsed: %d)"

local EMPTY_TABLE = {}

local GenericSignalTypeChecker = TypeGuard.Object({
    Connect = TypeGuard.Function();
    Wait = TypeGuard.Function();
    Fire = TypeGuard.Function();
}):Or(TypeGuard.RBXScriptSignal())

export type XSignal<T...> = {
    WaitNoTimeout: ((XSignal<T...>) -> (T...));
    Connect: ((XSignal<T...>, ((T...) -> ())) -> (Connection.Connection));
    Once: ((XSignal<T...>, ((T...) -> ())) -> (Connection.Connection));
    Fire: ((XSignal<T...>, T...) -> ());
    Wait: ((XSignal<T...>, number?, boolean?) -> (T...));
}

type GenericConnection = RBXScriptConnection | {
    Disconnect: (GenericConnection) -> ();
}
type GenericSignal = RBXScriptSignal | {
    Connect: (GenericSignal, any...) -> GenericConnection;
    Wait: (GenericSignal, any...) -> any...;
    Fire: (GenericSignal, any...) -> ();
}

local XSignal = {}
XSignal.__index = XSignal

local NewParams = TypeGuard.Params(TypeGuard.Function():Optional())
--- Constructs a new XSignal.
function XSignal.new(ImmediateFire: () -> (...any))
    if (CHECK_TYPES) then
        NewParams(ImmediateFire)
    end

    local self = setmetatable({
        _ConnectionCount = 0;

        _HeadConnection = nil;
        _ImmediateFire = ImmediateFire;

        _OnConnectionsEmpty = BLANK_FUNCTION;
        _OnConnectionsPresent = BLANK_FUNCTION;
    }, XSignal)

    self.Event = self -- Easy to port BindableEvents over in existing codebases

    return self
end

local ConnectParams = TypeGuard.Params(TypeGuard.Function():Optional())
--- Creates a new connection object given a callback function, which is called when the XSignal is fired.
function XSignal:Connect(Callback)
    if (CHECK_TYPES) then
        ConnectParams(Callback)
    end

    local NewConnection = Connection.new(self, Callback)
    NewConnection:Reconnect()

    local ImmediateFire = self._ImmediateFire

    if (ImmediateFire) then
        ImmediateFire(function(...)
            task.spawn(Callback, ...)
        end)
    end

    return NewConnection
end
XSignal.connect = XSignal.Connect

local OnceParams = TypeGuard.Params(TypeGuard.Function():Optional())
--- Connects the XSignal once and then disconnects
function XSignal:Once(Callback)
    if (CHECK_TYPES) then
        OnceParams(Callback)
    end

    local NewConnection; NewConnection = self:Connect(function(...)
        NewConnection:Disconnect()
        Callback(...)
    end)

    return NewConnection
end

--- Fires the XSignal, calling all connected callbacks in their own coroutine.
function XSignal:Fire(...)
    debug.profilebegin("XSignal.Fire")

    -- Resume all of the connections
    local Head = self._HeadConnection

    while (Head) do
        task.spawn(Head.Callback, ...)
        Head = Head._Next
    end

    debug.profileend()
end
XSignal.fire = XSignal.Fire

local WaitParams = TypeGuard.Params(TypeGuard.Number():Optional(), TypeGuard.Boolean():Optional())
--- Yields the current coroutine until the XSignal is fired, returning all data passed when the XSignal was fired.
function XSignal:Wait(Timeout, ThrowErrorOnTimeout)
    if (CHECK_TYPES) then
        WaitParams(Timeout, ThrowErrorOnTimeout)
    end

    Timeout = Timeout or DEFAULT_WAIT_TIMEOUT_SECONDS

    local ActiveCoroutine = coroutine.running()
    local Temp; Temp = self:Connect(function(...)
        -- Could return immediately from ImmediateFire, which would cause coroutine library error, so we check here
        local Args = {...}

        if (self._ImmediateFire) then

            task.defer(function()
                task.spawn(ActiveCoroutine, Args)
                Temp:Disconnect()
            end)

            return
        end

        task.spawn(ActiveCoroutine, Args)
        Temp:Disconnect()
    end)

    local DidTimeout = false
    local DidResume = false

    task.delay(Timeout, function()
        -- Could time out at a later point, so once we resume we know it is only yielding for this & can reject in future
        if (DidResume) then
            return
        end

        DidTimeout = true
        Temp:Disconnect() -- Safe for coroutine.close to be called
        task.spawn(ActiveCoroutine, EMPTY_TABLE)
    end)

    local Result = coroutine.yield()
    DidResume = true

    if (DidTimeout and ThrowErrorOnTimeout) then
        error(ERR_WAIT_TIMEOUT:format(Timeout))
    end

    return unpack(Result)
end
XSignal.wait = XSignal.Wait

-- Yields the XSignal indefinitely until it fires
function XSignal:WaitNoTimeout()
    local ActiveCoroutine = coroutine.running()
    local Temp; Temp = self:Connect(function(...)
        local Args = {...}

        if (self._ImmediateFire) then

            task.defer(function()
                task.spawn(ActiveCoroutine, Args)
                Temp:Disconnect()
            end)

            return
        end

        task.spawn(ActiveCoroutine, Args)
        Temp:Disconnect()
    end)

    return unpack(coroutine.yield())
end
XSignal.waitNoTimeout = XSignal.WaitNoTimeout

--- Flushes all connections from the Signal.
function XSignal:Destroy()
    self._HeadConnection = nil
    self._ConnectionCount = 0
    self._OnConnectionsEmpty()
end
XSignal.destroy = XSignal.Destroy
XSignal.DisconnectAll = XSignal.Destroy
XSignal.disconnectAll = XSignal.Destroy

local AwaitLikeParams = TypeGuard.Params(TypeGuard.Array(GenericSignalTypeChecker):MinLength(1), TypeGuard.Number():Optional(), TypeGuard.Boolean():Optional())
--- Awaits the completion of the first XSignal object and returns its fired data.
function XSignal.AwaitFirst(Signals: {GenericSignal}, Timeout: number?, ThrowErrorOnTimeout: boolean?): ...any
    if (CHECK_TYPES) then
        AwaitLikeParams(Signals, Timeout, ThrowErrorOnTimeout)
    end

    Timeout = Timeout or DEFAULT_AWAIT_FIRST_TIMEOUT_SECONDS

    local ActiveCoroutine = coroutine.running()
    local Connections = table.create(#Signals)

    for Index, Value in Signals do
        Connections[Index] = Value:Connect(function(...)
            task.spawn(ActiveCoroutine, ...)
        end)
    end

    local DidTimeout = false
    local DidResume = false

    task.delay(Timeout, function()
        if (DidResume) then
            return
        end

        DidTimeout = true

        for _, SubConnection in Connections do
            SubConnection:Disconnect()
        end

        task.spawn(ActiveCoroutine)
    end)

    local Result = {coroutine.yield()}
    DidResume = true

    for _, SubConnection in Connections do
        SubConnection:Disconnect()
    end

    if (DidTimeout and ThrowErrorOnTimeout) then
        error(ERR_WAIT_TIMEOUT:format(Timeout))
    end

    return unpack(Result)
end
XSignal.awaitFirst = XSignal.AwaitFirst

--- Awaits the completion of all Signal objects and returns their fired data in sub-arrays (for multiple arguments).
--- Return order is maintained for the Signals passed in.
function XSignal.AwaitAll(Signals: {GenericSignal}, Timeout: number?, ThrowErrorOnTimeout: boolean?): {{any}}
    if (CHECK_TYPES) then
        AwaitLikeParams(Signals, Timeout, ThrowErrorOnTimeout)
    end

    Timeout = Timeout or DEFAULT_AWAIT_ALL_TIMEOUT_SECONDS

    local TargetCount = #Signals
    local Result = table.create(TargetCount)
    local Connections = table.create(TargetCount)
    local ActiveCoroutine = coroutine.running()
    local Count = 0

    local DidTimeout = false
    local DidResume = false

    task.delay(Timeout, function()
        if (DidResume) then
            return
        end

        DidTimeout = true

        for _, SubConnection in Connections do
            SubConnection:Disconnect()
        end

        task.spawn(ActiveCoroutine)
    end)

    for Index, Value in Signals do
        local TempConnection; TempConnection = Value:Connect(function(...)
            TempConnection:Disconnect()
            Result[Index] = {...}
            Count += 1

            if (Count == TargetCount) then
                task.spawn(ActiveCoroutine)
            end
        end)

        table.insert(Connections, TempConnection)
    end

    coroutine.yield()
    DidResume = true

    if (DidTimeout and ThrowErrorOnTimeout) then
        error(ERR_WAIT_TIMEOUT:format(Timeout))
    end

    return Result
end
XSignal.awaitAll = XSignal.AwaitAll

--- Awaits the completion of all Signal objects and returns the first item of each of their arguments in an array.
--- Return order is maintained for the Signals passed in.
function XSignal.AwaitAllFirstArg(Signals: {GenericSignal}, Timeout: number?, ThrowErrorOnTimeout: boolean?): {any}
    if (CHECK_TYPES) then
        AwaitLikeParams(Signals, Timeout, ThrowErrorOnTimeout)
    end

    local Result = XSignal.AwaitAll(Signals, Timeout, ThrowErrorOnTimeout)
    local Reformatted = table.create(#Result)

    for Index, Value in Result do
        Reformatted[Index] = Value[1]
    end

    return Reformatted
end
XSignal.awaitAllFirstArg = XSignal.AwaitAllFirstArg

local ExtendParams = TypeGuard.Params(TypeGuard.Array(GenericSignalTypeChecker):MinLength(1))
--- Watches multiple other Signal objects and replicates firing through any of them.
function XSignal.Extend(Signals: {GenericSignal}, ...)
    if (CHECK_TYPES) then
        ExtendParams(Signals)
    end

    local NewSignal = XSignal.new(...)
    local ConnectionsList = table.create(#Signals)

    -- Unhook provided signals on object destruction
    NewSignal._OnConnectionsEmpty = function()
        for Index, SubConnection in ConnectionsList do
            SubConnection:Disconnect()
            ConnectionsList[Index] = nil
        end
    end

    -- Hook into all provided signals
    NewSignal._OnConnectionsPresent = function()
        for Index, SubSignal in Signals do
            assert(ConnectionsList[Index] == nil, ERR_CONNECTION_ALREADY_CREATED:format(Index))

            ConnectionsList[Index] = SubSignal:Connect(function(...)
                NewSignal:Fire(...)
            end)
        end
    end

    return NewSignal
end
XSignal.extend = XSignal.Extend

return XSignal]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">44709d6d8440808c02c9f1590002d25c</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBXAFE74A6029BD4885B6948AD8125A71A5">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Connection</string>
					<string name="ScriptGuid">{B5B75E06-33C0-4331-8AD8-44A8B3F237BF}</string>
					<ProtectedString name="Source"><![CDATA[export type Connection = {
    Connected: boolean,

    Disconnect: ((Connection) -> ()),
    Reconnect: ((Connection) -> ()),
}

local Connection = {}
Connection.__index = Connection

function Connection.new(SignalObject, Callback)
    return setmetatable({
        Connected = false;
        Callback = Callback;

        _Signal = SignalObject;
        _Next = nil;
    }, Connection)
end

function Connection:Disconnect()
    if (not self.Connected) then
        return
    end

    local SignalRef = self._Signal
    local Temp = SignalRef._HeadConnection

    if (Temp == nil) then
        return
    end

    if (Temp == self) then
        SignalRef._HeadConnection = self._Next
    else
        while (Temp._Next ~= self) do
            Temp = Temp._Next
        end

        Temp._Next = self._Next
    end

    ---------------------------------------------

    SignalRef._ConnectionCount -= 1

    if (SignalRef._ConnectionCount == 0) then
        SignalRef._HeadConnection = nil
        SignalRef._OnConnectionsEmpty()
    end

    self.Connected = false
end

function Connection:Reconnect()
    if (self.Connected) then
        return
    end

    local SignalRef = self._Signal
    local Head = SignalRef._HeadConnection

    if (Head) then
        self._Next = Head
        SignalRef._HeadConnection = self
    else
        SignalRef._HeadConnection = self
    end

    ---------------------------------------------

    SignalRef._ConnectionCount += 1

    if (SignalRef._ConnectionCount == 1) then
        SignalRef._OnConnectionsPresent()
    end

    self.Connected = true
end

return Connection]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">44709d6d8440808c02c9f1590002d25d</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX2AB0E98E579244728E1BB6AAC72D8527">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">init.spec</string>
					<string name="ScriptGuid">{D923C169-7085-4AD7-ADD9-D11BF2189D62}</string>
					<ProtectedString name="Source"><![CDATA[return function()
    local XSignal = require(script.Parent)

    describe("XSignal.new", function()
        it("should construct", function()
            expect(function()
                XSignal.new()
            end).never.to.throw()
        end)

        it("should reject non-function types as first arg", function()
            expect(function()
                XSignal.new(1)
            end).to.throw()
        end)

        it("should accept a function as first arg", function()
            expect(function()
                XSignal.new(function() end)
            end).never.to.throw()
        end)
    end)

    describe("XSignal.Connect", function()
        it("should throw when not given a function", function()
            expect(function()
                XSignal.new():Connect(1)
            end).to.throw()
        end)

        it("should accept a callback", function()
            expect(function()
                XSignal.new():Connect(function() end)
            end).never.to.throw()
        end)

        it("should accept multiple callbacks", function()
            expect(function()
                local Test = XSignal.new()
                Test:Connect(function() end)
                Test:Connect(function() end)
                Test:Connect(function() end)
            end).never.to.throw()
        end)

        it("should allow disconnection", function()
            local Test = XSignal.new()

            local X = Test:Connect(function() end)
            local Y = Test:Connect(function() end)
            local Z = Test:Connect(function() end)

            expect(X.Disconnect).to.be.a("function")
            expect(Y.Disconnect).to.be.a("function")
            expect(Z.Disconnect).to.be.a("function")

            expect(function()
                X:Disconnect()
                Y:Disconnect()
                Z:Disconnect()
            end).never.to.throw()
        end)
    end)

    describe("XSignal.Connect(ImmediateFire)", function()
        it("should immediately fire for new connections using callback (in order)", function()
            local Test = XSignal.new(function(Callback)
                Callback(1, 2)
                Callback(3, 4)
                Callback(5, 6)
            end)

            local Results = {}

            Test:Connect(function(Num1, Num2)
                table.insert(Results, Num1)
                table.insert(Results, Num2)
            end)

            expect(table.concat(Results)).to.equal("123456")
        end)
    end)

    describe("XSignal.Once", function()
        -- TODO
    end)

    describe("XSignal.Fire", function()
        it("should execute a connection", function()
            local Test = XSignal.new()
            local FiredCount = 0

            Test:Connect(function()
                FiredCount += 1
            end)

            expect(FiredCount).to.equal(0)
            Test:Fire()
            expect(FiredCount).to.equal(1)
        end)

        it("should execute multiple connections", function()
            local Test = XSignal.new()
            local FiredCount = 0

            Test:Connect(function()
                FiredCount += 1
            end)

            Test:Connect(function()
                FiredCount += 1
            end)

            Test:Connect(function()
                FiredCount += 1
            end)

            expect(FiredCount).to.equal(0)
            Test:Fire()
            expect(FiredCount).to.equal(3)
        end)

        it("should execute multiple connections async", function()
            local Test = XSignal.new()
            local FiredCount = 0

            Test:Connect(function()
                task.wait(0.1)
                FiredCount += 1
            end)

            Test:Connect(function()
                task.wait(0.1)
                FiredCount += 1
            end)

            expect(FiredCount).to.equal(0)
            Test:Fire()
            expect(FiredCount).to.equal(0)
            task.wait(0.1)
            expect(FiredCount).to.equal(2)
        end)

        it("should pass primitive data types", function()
            local Test = XSignal.new()

            Test:Connect(function(X, Y, Z)
                expect(X).to.equal(1)
                expect(Y).to.equal("s")
                expect(Z).to.equal(true)
            end)

            Test:Fire(1, "s", true)
        end)

        it("should pass objects", function()
            local Test = XSignal.new()
            local Pass1 = {}
            local Pass2 = {}

            Test:Connect(function(X, Y)
                expect(X).to.equal(Pass1)
                expect(Y).to.equal(Pass2)
            end)

            Test:Fire(Pass1, Pass2)
        end)

        it("should not execute disconnected connections", function()
            local Test = XSignal.new()
            local RunCount = 0

            Test:Connect(function()
                RunCount += 1
            end)

            Test:Connect(function()
                RunCount += 1
            end)

            Test:Connect(function()
                RunCount += 1
            end):Disconnect()

            Test:Fire()
            expect(RunCount).to.equal(2)
        end)
    end)

    describe("XSignal.Wait", function()
        it("should yield until the XSignal is fired", function()
            local Test = XSignal.new()

            task.delay(0.1, function()
                Test:Fire()
            end)

            Test:Wait()
        end)

        it("should timeout and pass nil if no error is desired", function()
            local Test = XSignal.new()
            expect(Test:Wait(0.1)).to.equal(nil)
        end)

        it("should timeout and throw if an error is desired", function()
            local Test = XSignal.new()

            expect(pcall(function()
                Test:Wait(0.1, true)
            end)).to.equal(false)
        end)

        it("should return the data passed to the XSignal", function()
            local Test = XSignal.new()
            local TestObject = {}

            task.defer(function()
                Test:Fire(1, TestObject)
            end)

            local Primitive, Object = Test:Wait()
            expect(Primitive).to.equal(1)
            expect(Object).to.equal(TestObject)
        end)

        it("should return immediately with ImmediateFire", function()
            local TestObject = {}
            local Test = XSignal.new(function(Callback)
                Callback(3210, TestObject)
            end)

            local Primitive, Object = Test:Wait(0.1, true)
            expect(Primitive).to.equal(3210)
            expect(Object).to.equal(TestObject)
        end)
    end)

    describe("XSignal.WaitNoTimeout", function()
        it("should yield until the XSignal is fired", function()
            local Test = XSignal.new()

            task.delay(0.1, function()
                Test:Fire()
            end)

            Test:WaitNoTimeout()
        end)

        it("should return the data passed to the XSignal", function()
            local Test = XSignal.new()
            local TestObject = {}

            task.defer(function()
                Test:Fire(1, TestObject)
            end)

            local Primitive, Object = Test:WaitNoTimeout()
            expect(Primitive).to.equal(1)
            expect(Object).to.equal(TestObject)
        end)
    end)

    describe("XSignal.DisconnectAll", function()
        it("should wipe all connections", function()
            local Test = XSignal.new()
            local RunCount = 0

            Test:Connect(function()
                RunCount += 1
            end)

            Test:Connect(function()
                RunCount += 1
            end)

            Test:Connect(function()
                RunCount += 1
            end)

            expect(RunCount).to.equal(0)
            Test:DisconnectAll()
            Test:Fire()
            expect(RunCount).to.equal(0)
        end)
    end)

    describe("XSignal.Extend", function()
        it("should throw when no XSignals to extend are passed", function()
            expect(function()
                XSignal.Extend()
            end).to.throw()

            expect(function()
                XSignal.Extend({})
            end).to.throw()
        end)

        it("should create a new XSignal which replicates firing from a single XSignal", function()
            local TestObject = {}
            local SubSignal = XSignal.new()
            local Test = XSignal.Extend({SubSignal})

            local Data

            Test:Connect(function(...)
                Data = {...}
            end)

            SubSignal:Fire(1, TestObject)

            expect(Data).to.be.ok()
            expect(Data).to.be.a("table")
            expect(Data[1]).to.equal(1)
            expect(Data[2]).to.equal(TestObject)
        end)

        it("should create a new XSignal which replicates firing from multiple XSignals", function()
            local TestObject1 = {}
            local TestObject2 = {}

            local SubSignal1 = XSignal.new()
            local SubSignal2 = XSignal.new()

            local Test = XSignal.Extend({SubSignal1, SubSignal2})

            local Data

            Test:Connect(function(...)
                Data = {...}
            end)

            SubSignal1:Fire(1, TestObject1)
            expect(Data).to.be.ok()
            expect(Data).to.be.a("table")
            expect(Data[1]).to.equal(1)
            expect(Data[2]).to.equal(TestObject1)

            SubSignal1:Fire(2, TestObject2)
            expect(Data).to.be.ok()
            expect(Data).to.be.a("table")
            expect(Data[1]).to.equal(2)
            expect(Data[2]).to.equal(TestObject2)
        end)
    end)

    describe("XSignal.AwaitFirst", function()
        it("should throw for incorrect args", function()
            expect(function()
                XSignal.AwaitFirst()
            end).to.throw()

            expect(function()
                XSignal.AwaitFirst({})
            end).to.throw()

            expect(function()
                XSignal.AwaitFirst({XSignal.new()}, "")
            end).to.throw()

            expect(function()
                XSignal.AwaitFirst({XSignal.new()}, 0.1, "")
            end).to.throw()
        end)

        it("should timeout and pass nil if no error is desired", function()
            expect(XSignal.AwaitFirst({XSignal.new()}, 0.1)).to.equal(nil)
        end)

        it("should timeout and throw if an error is desired", function()
            expect(function()
                XSignal.AwaitFirst({XSignal.new()}, 0.1, true)
            end).to.throw()
        end)

        it("should resume a coroutine with the first XSignal to fire", function()
            local Signal1 = XSignal.new()
            local Signal2 = XSignal.new()

            task.delay(0.1, function()
                Signal1:Fire()
            end)

            XSignal.AwaitFirst({Signal1, Signal2})

            task.delay(0.1, function()
                Signal2:Fire()
            end)

            XSignal.AwaitFirst({Signal1, Signal2})
        end)

        it("should return the standard 'Wait' data passed from the wrapped XSignal", function()
            local TestObject = {}
            local Signal1 = XSignal.new()
            local Signal2 = XSignal.new()

            task.delay(0.1, function()
                Signal1:Fire(1, TestObject)
            end)

            local X, Y = XSignal.AwaitFirst({Signal1, Signal2})
            expect(X).to.equal(1)
            expect(Y).to.equal(TestObject)
        end)
    end)

    describe("XSignal.AwaitAll", function()
        it("should throw for incorrect args", function()
            expect(function()
                XSignal.AwaitAll()
            end).to.throw()

            expect(function()
                XSignal.AwaitAll({})
            end).to.throw()

            expect(function()
                XSignal.AwaitAll({XSignal.new()}, "")
            end).to.throw()

            expect(function()
                XSignal.AwaitAll({XSignal.new()}, 0.1, "")
            end).to.throw()
        end)

        it("should timeout and pass a blank array if no error is desired", function()
            expect(next(XSignal.AwaitAll({XSignal.new()}, 0.1))).to.equal(nil)
        end)

        it("should timeout and throw if an error is desired", function()
            expect(function()
                XSignal.AwaitAll({XSignal.new()}, 0.1, true)
            end).to.throw()
        end)

        it("should await all XSignals, not just one", function()
            local Signal1 = XSignal.new()
            local Signal2 = XSignal.new()
            local Running = coroutine.running()

            task.delay(0.1, function()
                Signal1:Fire()
                expect(coroutine.status(Running)).to.equal("suspended")

                task.wait(0.1)
                Signal2:Fire()
            end)

            XSignal.AwaitAll({Signal1, Signal2})
        end)

        it("should return the standard 'Wait' data passed from the wrapped XSignals, in a two-dimensional array format, in the order they were passed into the function", function()
            local TestObject = {}
            local Signal1 = XSignal.new()
            local Signal2 = XSignal.new()
            local Running = coroutine.running()

            task.delay(0.1, function()
                Signal1:Fire(1, TestObject)
                expect(coroutine.status(Running)).to.equal("suspended")

                task.wait(0.1)
                Signal2:Fire(2, TestObject)
            end)

            local Results = XSignal.AwaitAll({Signal1, Signal2})
            expect(Results).to.be.ok()
            expect(Results).to.be.a("table")
            expect(Results[1]).to.be.ok()
            expect(Results[1]).to.be.a("table")
            expect(Results[1][1]).to.equal(1)
            expect(Results[1][2]).to.equal(TestObject)
            expect(Results[2]).to.be.ok()
            expect(Results[2]).to.be.a("table")
            expect(Results[2][1]).to.equal(2)
            expect(Results[2][2]).to.equal(TestObject)
        end)
    end)

    describe("XSignal.AwaitAllFirstArg", function()
        it("should return the standard 'Wait' data passed from the wrapped XSignals, in a one-dimensional array format, in the order they were passed into the function", function()
            local TestObject = {}
            local Signal1 = XSignal.new()
            local Signal2 = XSignal.new()
            local Running = coroutine.running()

            task.delay(0.1, function()
                Signal1:Fire(1, TestObject)
                expect(coroutine.status(Running)).to.equal("suspended")

                task.wait(0.1)
                Signal2:Fire(2, TestObject)
            end)

            local Results = XSignal.AwaitAllFirstArg({Signal1, Signal2})
            expect(Results).to.be.ok()
            expect(Results).to.be.a("table")
            expect(Results[1]).to.be.ok()
            expect(Results[1]).to.be.a("number")
            expect(Results[1]).to.equal(1)
            expect(Results[2]).to.be.ok()
            expect(Results[2]).to.be.a("number")
            expect(Results[2]).to.equal(2)
        end)
    end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">44709d6d8440808c02c9f1590002d25e</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="TweenService" referent="RBX5CA85E194FC442928555CE97BD7F1EAC">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fae4</UniqueId>
		</Properties>
	</Item>
	<Item class="MaterialService" referent="RBX9AD375AE41424DF0946EFEB9221E83E0">
		<Properties>
			<string name="AsphaltName">Asphalt</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="BasaltName">Basalt</string>
			<string name="BrickName">Brick</string>
			<string name="CobblestoneName">Cobblestone</string>
			<string name="ConcreteName">Concrete</string>
			<string name="CorrodedMetalName">CorrodedMetal</string>
			<string name="CrackedLavaName">CrackedLava</string>
			<string name="DiamondPlateName">DiamondPlate</string>
			<string name="FabricName">Fabric</string>
			<string name="FoilName">Foil</string>
			<string name="GlacierName">Glacier</string>
			<string name="GraniteName">Granite</string>
			<string name="GrassName">Grass</string>
			<string name="GroundName">Ground</string>
			<string name="IceName">Ice</string>
			<string name="LeafyGrassName">LeafyGrass</string>
			<string name="LimestoneName">Limestone</string>
			<string name="MarbleName">Marble</string>
			<string name="MetalName">Metal</string>
			<string name="MudName">Mud</string>
			<string name="Name">MaterialService</string>
			<string name="PavementName">Pavement</string>
			<string name="PebbleName">Pebble</string>
			<string name="PlasticName">Plastic</string>
			<string name="RockName">Rock</string>
			<string name="SaltName">Salt</string>
			<string name="SandName">Sand</string>
			<string name="SandstoneName">Sandstone</string>
			<string name="SlateName">Slate</string>
			<string name="SmoothPlasticName">SmoothPlastic</string>
			<string name="SnowName">Snow</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fae5</UniqueId>
			<bool name="Use2022MaterialsXml">false</bool>
			<string name="WoodName">Wood</string>
			<string name="WoodPlanksName">WoodPlanks</string>
		</Properties>
	</Item>
	<Item class="TextChatService" referent="RBXB258290546B942F599B4F533AD319AD8">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="ChatVersion">0</token>
			<bool name="CreateDefaultCommands">true</bool>
			<bool name="CreateDefaultTextChannels">true</bool>
			<string name="Name">TextChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fae6</UniqueId>
		</Properties>
		<Item class="ChatWindowConfiguration" referent="RBX4CC46B4663524952832D53F84281408F">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Enabled">true</bool>
				<string name="Name">ChatWindowConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb8c</UniqueId>
			</Properties>
		</Item>
		<Item class="ChatInputBarConfiguration" referent="RBXE2BED8795CAC4EAC850188D49AB72E8C">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Enabled">true</bool>
				<string name="Name">ChatInputBarConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Ref name="TargetTextChannel">null</Ref>
				<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb8d</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="PermissionsService" referent="RBX9040EEA145264936B9583B3F3D2504E2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001faea</UniqueId>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBX4C0E8D3853A3423395CA0DEDB26652D7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CustomPoliciesEnabled">false</bool>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001faec</UniqueId>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBXFFA1C77FD32F4706AB8BE10D70781866">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int64 name="CommitInflightAuthorId">0</int64>
			<string name="CommitInflightGuid"></string>
			<int name="CommitInflightPlaceVersion">0</int>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<int64 name="SrcPlaceId">0</int64>
			<int64 name="SrcUniverseId">0</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001faef</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="RBX02CC2ADF47C84A93BB1F68D6BE4B67EA">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<bool name="LoadCharacterAppearance">true</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001faf0</UniqueId>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="RBXEC46319A7DCA44109CB6E1B0EB414B3D">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb8a</UniqueId>
			</Properties>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBX94B08E02447741EE9CCF647E8A61B018">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb8b</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBX2AEABA47E5AE40E5B08B16BDDDE7DCCF">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001faf1</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX98D20B939E7346458516A08012BE3242">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001faf2</UniqueId>
			<token name="VirtualCursorMode">0</token>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBXFB5F2345C8E34252BDC5360FFA9C0029">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001faf4</UniqueId>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX0E7DE04E0023451E88F54A66A010BD4E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001faf8</UniqueId>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBXFA386560BE05409FB7D61FC7615AC6E3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fafa</UniqueId>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX339D8190C6C048F4AE4811ADEE133462">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fafb</UniqueId>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBX6D426B8B2A574010B942592D83530190">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Geometry</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fafd</UniqueId>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBX63D37203F7164F26BB2808F5B0BA6500">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001faff</UniqueId>
		</Properties>
		<Item class="StringValue" referent="RBXEB3543FB1B8E492EB246D193C845078F">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">30de511b20dfe51202c9efe10002c500</UniqueId>
				<string name="Value">{A53A4CAC-BF9A-4DA1-B779-48B2DEB59EF3}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBX7094207FDC9B40BA8D06D6973D6E30DD">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb00</UniqueId>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBXF0A0B0F9098D479BB486E1225EB305D4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb01</UniqueId>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBXA4CA7AA6534D4E3390E4A501192F4A85">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb02</UniqueId>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBX31C4CE37428D4F609E25277068595DBA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb0c</UniqueId>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBX4D9A4093BE244818BF279C1BA1E50587">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb0e</UniqueId>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBX48D862C88F074AE0A9561482ECC0E92B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb10</UniqueId>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBX4DFB35E515164388AB3644BC58D78E45">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb11</UniqueId>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBXCE86B9E2D421458985521933676EB7A4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb12</UniqueId>
		</Properties>
	</Item>
	<Item class="AnalyticsService" referent="RBXCE06E070913C48CA9A263AF4A0C00300">
		<Properties>
			<string name="ApiKey"></string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AnalyticsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb15</UniqueId>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX6701BDAF0A834ABDB37EC9BD47869463">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb18</UniqueId>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="RBX7ADE6520C7024B5CB8C7CAC24F0AFEB1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb1a</UniqueId>
		</Properties>
	</Item>
	<Item class="ServerStorage" referent="RBX26DDA207F9F3440D8CC1A69B0935981E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb1b</UniqueId>
		</Properties>
	</Item>
	<Item class="ReplicatedStorage" referent="RBX9C7DF789F7454C1683C66691B9899B38">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb1c</UniqueId>
		</Properties>
	</Item>
	<Item class="LuaWebService" referent="RBX3BF31E7DE6674209A3B0CD9F714B785A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb23</UniqueId>
		</Properties>
	</Item>
	<Item class="ProcessInstancePhysicsService" referent="RBXE45A5B4BAE004A8D9F10C65DA59DF0CF">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ProcessInstancePhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb24</UniqueId>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBX90749DB9558E4314A650354C716AEE9F">
		<Properties>
			<Color3 name="Ambient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="Brightness">1</float>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">false</bool>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">true</bool>
			<float name="ShadowSoftness">0.5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">2</token>
			<string name="TimeOfDay">14:00:00</string>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb50</UniqueId>
		</Properties>
	</Item>
	<Item class="LodDataService" referent="RBX43256E33773741EEB17752381EB853D0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10001fb53</UniqueId>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBX65419119F3B24FDC988C359391B15FF9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="HttpEnabled">false</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe100027e13</UniqueId>
		</Properties>
	</Item>
	<Item class="Teams" referent="RBX19CDEDA0C8974B85B5598B4F057753B7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teams</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10002b3b6</UniqueId>
		</Properties>
	</Item>
	<Item class="VirtualInputManager" referent="RBX68373285E0054B2F8763D07C30DA7B80">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">VirtualInputManager</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10002b3d4</UniqueId>
		</Properties>
	</Item>
	<Item class="LanguageService" referent="RBX298BD0FE94F1474C84C9970699D1EFBB">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LanguageService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10002b60f</UniqueId>
		</Properties>
	</Item>
	<Item class="ProximityPromptService" referent="RBX514085E65703464C95F9156C09CA1D75">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="Enabled">true</bool>
			<int name="MaxPromptsVisible">16</int>
			<string name="Name">ProximityPromptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10002b746</UniqueId>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBXE34EB0B90E594A4A893E23962E718A92">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<bool name="Is30FpsThrottleEnabled">true</bool>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
			<UniqueId name="UniqueId">30de511b20dfe51202c9efe10002c518</UniqueId>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>